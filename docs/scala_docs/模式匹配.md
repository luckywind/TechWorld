[参考资料](https://hongjiang.info/scala-pattern-matching-1/)

**模式(pattern)**，这里所的模式并不是设计模式里的模式，而是数据结构上的，这个模式用于描述一个结构的组成。

scala有如下几种形式的模式匹配

1. 常量模式

就是if/else，没啥威力

```scala
scala> val site = "alibaba.com"
scala> site match { case "alibaba.com" => println("ok") }
scala> val ALIBABA="alibaba.com"
//注意这里常量必须以大写字母开头
scala> def foo(s:String) { s match { case ALIBABA => println("ok") } }
```

2. 变量模式

确切的说单纯的变量模式没有匹配判断的过程，只是把传入的对象给起了一个新的变量名。也没啥威力

```scala
scala> site match { case whateverName => println(whateverName) }
```

3. 通配符模式

单纯的通配符模式可以匹配任何对象

```scala
scala> List(1,2,3) match{ case List(_,_,3) => println("ok") }
```

4. 构造器模式

```scala
scala> :paste
//抽象节点
trait Node 
//具体的节点实现，有两个子节点
case class TreeNode(v:String, left:Node, right:Node) extends Node 
//Tree，构造参数是根节点
case class Tree(root:TreeNode)  
scala>val tree = Tree(TreeNode("root",TreeNode("left",null,null),TreeNode("right",null,null)))
scala> tree.root match { 
        case TreeNode(_, TreeNode("left",_,_), TreeNode("right",null,null)) =>
             println("bingo") 
    }
```

5. 类型匹配

跟 isInstanceOf 判断类型的效果一样，需要注意的是scala匹配泛型时要注意，
比如

```scala
scala> def foo(a:Any) = a match { 
            case a :List[String] => println("ok"); 
            case _ => 
        } 
```

**如果使用了泛型，它会被擦拭掉**，如同java的做法，所以上面的 List[String] 里的String运行时并不能检测
`foo(List("A"))` 和 `foo(List(2))` 都可以匹配成功。

6. 变量绑定模式

依然是上面的TreeNode，如果我们希望匹配到左边节点值为”left”就返回这个节点的话：

```scala
scala> tree.root match { 
         case TreeNode(_, leftNode@TreeNode("left",_,_), _) => leftNode 
        }
```

用`@`符号绑定 leftNode变量到匹配到的左节点上，只有匹配成功才会绑定

[模式匹配和函数组合](https://www.iteblog.com/archives/1660.html?from=like)

