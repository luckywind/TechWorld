[pregel 与 spark graphX 的 pregel api](https://blog.csdn.net/u013468917/article/details/51199808)

```scala
import org.apache.spark._
import org.apache.spark.graphx._
import org.apache.spark.rdd.RDD

val graph = GraphLoader.edgeListFile(sc,"/Spark/web-Google.txt")
val sourceId: VertexId = 0
val initialGraph = graph.mapVertices((id, _) => if (id == sourceId) 0.0 else Double.PositiveInfinity)

val sssp = initialGraph.pregel(Double.PositiveInfinity)(
  (id, dist, newDist) => math.min(dist, newDist), // Vertex Program
  triplet => { // Send Message
  if (triplet.srcAttr + triplet.attr < triplet.dstAttr) {
  Iterator((triplet.dstId, triplet.srcAttr + triplet.attr))
    } else {
    Iterator.empty
    }
  },
  (a,b) => math.min(a,b) // Merge Message
)
sssp.vertices.take(10).mkString("\n")

```



# pregel方法

这个方法的签名实际是一个柯里化函数，第一个参数集的后两个都有默认值

```scala
  def pregel[A: ClassTag](      // A:消息的类型
      initialMsg: A,         //参数1: 第一次迭代时向每个点发送的消息
      maxIterations: Int = Int.MaxValue, //参数2:最大迭代次数，默认int最大值
      activeDirection: EdgeDirection = EdgeDirection.Either)(//参数3: 决定了边是否发送消息，详细解释见下文
      vprog: (VertexId, VD, A) => VD,     // 参数1
      sendMsg: EdgeTriplet[VD, ED] => Iterator[(VertexId, A)],
      mergeMsg: (A, A) => A)
    : Graph[VD, ED] = {
    Pregel(graph, initialMsg, maxIterations, activeDirection)(vprog, sendMsg, mergeMsg)
  }
```

## 第一个参数集合

      initialMsg: A,         //参数1: 第一次迭代时向每个点发送的消息
      maxIterations: Int = Int.MaxValue, //参数2:最大迭代次数，默认int最大值
      activeDirection: EdgeDirection = EdgeDirection.Either  //参数3: 决定了边是否发送消息，详细解释见下文

activeDirection：

如果一个边的所有端点在本轮迭代中都没收到消息，则这个边不再调用sendMsg方法。activeDirection参数指定了过滤器：

-   *EdgeDirection.Out*—sendMsg gets called if srcId received a message during the previous iteration, meaning this edge is considered an “out-edge” of srcId.

  源点接收到消息，即出边调用

-   *EdgeDirection.In*—sendMsg gets called if dstId received a message during the previous iteration, meaning this edge is considered an “in-edge” of dstId.

 	  目的点接收到消息，即入边调用

-   *EdgeDirection.Either*—sendMsg gets called if either srcId or dstId received a message during the previous iteration.

​		有一个端点收到消息

-   *EdgeDirection.Both* —sendMsg gets called if both srcId and dstId received mes- sages during the previous iteration.

​		两个端点都接收到消息	    

## 第二个参数集合

      vprog: (VertexId, VD, A) => VD,     // 参数1
      sendMsg: EdgeTriplet[VD, ED] => Iterator[(VertexId, A)],
      mergeMsg: (A, A) => A)

pregel的功能其实和迭代版本的aggregateMessages有点像，但有一些区别：

1. aggregateMessages只需要定义两个函数定义它的行为： send- Msg 和 mergeMsg.

vprog提供了更灵活的逻辑，一些场景下点的数据类型和消息的类型相同，只需要简单的逻辑就可以更新点的值。 还有一些情况，点的值类型和消息类型不同，vprog如何处理？。

2. sendMsg函数的签名

EdgeTriplet包含边及其两个端点的信息，EdgeContext额外增加了两个方法sendToSrc 和 sendToDst.

```scala
aggregateMessages中：
EdgeContext[VD, ED, Msg] => Unit


Pregel中
sendMsg: EdgeTriplet[VD, ED] => Iterator[(VertexId, A)]
```

这个差异的原因是Pregel还依赖过时的mapReduceTriplets，还没有升级到aggregateMessages上来，但这个工作已经在进行中了。



