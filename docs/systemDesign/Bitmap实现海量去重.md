# 利用bitmap实现去重

[参考](https://developer.51cto.com/art/202112/694196.htm)

一个unsigned int（32个bit）类型数据可以标识0~31这32个整数的存在与否。

$$512M=512*2^10*2^10*8=2^{9}*2^{10}*2^{10}*2^{3}bit=2^{31}bit\approx int的最大值43亿$$  个bit位。

用一个512M的无符号int数组来记录一个QQ号是否存在形成一个bitmap，

![image-20211219221616968](https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image/image-20211219221616968.png)

这个过程实际上自动完成了去重， 然后遍历所有正整数，当数组的值为1时，就表明该数是存在的。

## 无重复数据的排序

如果数据没有重复，很显然，直接用bitmap, 标记这40亿个QQ号码的存在性，然后从小到大遍历正整数，当bitmapFlag的值为1时，就输出该值，输出后的正整数序列就是排序后的结果。

## 无重复数据中位数

还是用bitmap存储，然后从小到大遍历正整数，当数到全部数据的一半时就找到中位数了

## 无重复数据TopK

还是用bitmap存储，然后从大到小遍历正整数，找出存在的K个就行了。

## 判断是否有重复

**文件中有80亿个QQ号码，试判断其中是否存在相同的QQ号码，内存限制1G。**

根据容斥原理可知：

因为QQ号码的个数是43亿左右(理论值2^32 - 1)，所以80亿个QQ号码必然存在相同的QQ号码。

## 重复n次的元素

在3亿个整数中找出重复>=2次的整数，限制内存不足以容纳3亿个整数。

　　对于这种场景我可以采用2-BitMap来解决，即为每个整数分配2bit，用不同的0、1组合来标识特殊意思，如00表示此整数没有出现过，01表示出现一次，11表示出现过多次，就可以找出重复的整数了，其需要的内存空间是正常BitMap的2倍，为：3亿*2/8/1024/1024=71.5MB。

具体的过程如下：

　　扫描着3亿个整数，组BitMap，先查看BitMap中的对应位置，如果00则变成01，是01则变成11，是11则保持不变，当将3亿个整数扫描完之后也就是说整个BitMap已经组装完毕。最后查看BitMap将对应位为11的整数输出即可。







# bitmap实现原理

[参考](https://www.yisu.com/zixun/528613.html)

[BitMap的Java实现](https://sustcoder.github.io/2018/10/23/2018-10-23-bitMap-explain-and-use/)

假如我们用int字节码的每一位表示一个数字的话，**那么32个数字只需要一个int类型所占内存空间大小就够了**，这样在大数据量的情况下会节省很多内存。

　1个int占4字节即4*8=32位，那么我们只需要申请一个int数组长度为 int tmp[1+N/32]即可存储完这些数据，其中N代表要进行查找的总数，tmp中的每个元素在内存在占32位可以对应表示十进制数0~31,所以可得到BitMap表:

```java
　　　　tmp[0]:可表示0~31     32位
　　　　tmp[1]:可表示32~63    32位
　　　　tmp[2]可表示64~95     32位
　　　　.......
```

如何判断int数字在tmp数组的哪个下标，这个其实可以通过直接除以32取整数部分，也就是右移动5位。

如何判断数字在该下标的32位中的哪一位？ 直接mod上32就可以。例如8，除以32取整为0，则在tmp[0]上，8mod32=8，所以在下标0的第8位（从右边数起，从0开始数）。

<img src="https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image/bitMap.jpg" alt="bitMap.jpg" style="zoom:50%;" />

对于一个十进制数n,对应在数组`bitsMap[n/32][n%32]`中，但数组bitsMap毕竟不是一个二维数组, 我们通过移位操作实现



![image-20211221210415364](https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image/image-20211221210415364.png)



```java
public class BitMap
{
	private long length;
	private static int[] bitsMap;
  //16进制数组，长度32
	private static final int[] BIT_VALUE = {0x00000001, 0x00000002, 0x00000004, 0x00000008, 0x00000010, 0x00000020,
			0x00000040, 0x00000080, 0x00000100, 0x00000200, 0x00000400, 0x00000800, 0x00001000, 0x00002000, 0x00004000,
			0x00008000, 0x00010000, 0x00020000, 0x00040000, 0x00080000, 0x00100000, 0x00200000, 0x00400000, 0x00800000,
			0x01000000, 0x02000000, 0x04000000, 0x08000000, 0x10000000, 0x20000000, 0x40000000, 0x80000000};
//参与&运算时，要转成二进制， 实际上就是1左移n位，n从0一直到31， 也可用1 << offset来表示
//{1,10,100,1000,10000,100000,10^6,10^7,10^8,...., 10^32}
  

	public BitMap(long length)
	{
		this.length = length;
		/**
		 * 根据长度算出，所需数组大小
		 * 当 length%32=0 时大小等于 = length/32
		 * 当 length%32>0 时大小等于 = length/32+l
		 */
    bitsMap = new int[(int)
        (length >> 5)  //除以2^5
        + ((length & 31) > 0 ? 1 : 0)//32=2^5,所以length&(32-1)=length%32
        ];
	}

	/**
	 * @param n 要被设置的值为n
	 */
	public void setN(long n)
	{
		if (n < 0 || n > length)
		{
			throw new IllegalArgumentException("length value " + n + " is  illegal!");
		}
		// 求出该n所在bitMap的下标,等价于"n/5"
		int index = (int) n >> 5;
		// 求出该值的偏移量(求余),等价于"n%31" 
		int offset = (int) n & 31;
		/**
		 * 或操作，偏移量offset处的结果一定是1
		   在查的时候，是取与操作，如果存在，则与操作在偏移量offset处的结果一定是1，
		   最后再无符号右移动offset位，就得到00...001的二进制，值为1，即存在。
		 */
		bitsMap[index] |= BIT_VALUE[offset];
    //bitsMap[index] |= (1 << offset); 还可以这么写，这样就省掉了BIT_VALUE

	}

	/**
	 * 获取值N是否存在
	 * @return 1：存在，0：不存在
	 */
	public int isExist(long n)
	{
		if (n < 0 || n > length)
		{
			throw new IllegalArgumentException("length value illegal!");
		}
		int index = (int) n >> 5;
		int offset = (int) n & 31;
		int bits = (int) bitsMap[index];
		return ((bits & BIT_VALUE[offset])) >>> offset;
	}

	public static void main(String[] args)
	{
		BitMap map = new BitMap(64);
		map.setN(6);
		map.setN(3);
		map.setN(8);
		map.setN(32);
		map.setN(35);
		System.out.println(map.isExist(34));

	}
}
```

# 快速计算
## 移位代替乘除
a=a*4;
b=b/4;
　可以改为
a=a<<2;
b=b>>2;

**实际上，只要是乘以或除以一个整数，均可以用移位的方法得到结果，**如：

```
　　a=a*9
　　分析a*9可以拆分成a*(8+1)即a*8+a*1, 因此可以改为： a=(a<<3)+a
　　a=a*7
　　分析a*7可以拆分成a*(8-1)即a*8-a*1, 因此可以改为： a=(a<<3)-a
```




## 与运算&代替取模运算%

位运算(&)效率要比取模运算(%)高很多，主要原因是位运算直接对内存数据进行操作，不需要转成十进制，因此处理速度非常快。

当b为$$2^{n}$$ 时，取模运算可以用与运算代替：  a % b == a & (b - 1)



### 原理

X % 2^n = X & (2^n - 1)

左边： 取模操作就是除法的余数，从二进制角度看，就是向右移动n位，余数就是被移掉的后面的n位

右边：2^n-1 的二进制形式就是n位1

两者当然想等！

假设 n 为 3，则 2^3 = 8，表示成 2 进制就是 1000。2^3 - 1 = 7 ，即 0111。

此时 X & (2^3 - 1) 就相当于取 X 的 2 进制的最后三位数。

从 2 进制角度来看，X / 8 相当于 X >> 3，即把 X 右移 3 位，此时得到了 X / 8 的商，而被移掉的部分(后三位)，则是 X % 8，也就是余数。

# 二进制

左移<< ：就是该数对应二进制码整体左移，左边超出的部分舍弃，右边补零

右移>> : 该数对应的二进制码整体右移，左边的用原有标志位补充，右边超出的部分舍弃。

无符号右移>>>:不管正负标志位为0还是1，将该数的二进制码整体右移，左边部分总是以0填充，右边部分舍弃。

对于移位运算，例如将x左移/右移n位，如果x是byte、short、char、int，**n会先模32（即n=n%32），然后再进行移位操作**。可以这样解释：int类型为32位,移动32位（或以上）没有意义。

## 原码/反码/补码

int型占两个字节，也就是8个bit位，为了能表示负数，第一位是符号位，其余是数字位

<img src="https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image/image-20211221001016449.png" alt="image-20211221001016449" style="zoom:50%;" />

为什么需要反码/补码呢？ 正数和负数的二进制直接相加会有问题，例如1和-1的二进制相加并不等于0:

```
 0000 0001
+1000 0001
=1000 0010
=-2
```



原码： 十进制数字的二进制表示就是原码， 有了原码就按规则产生反码/补码

规则： 

正数： 原码=反码=补码

负数： 反码=符号位不变，其他位取反

​			补码=反码+1

如果都转成补码再想加就没问题！

补码如何转回原码？ 规则一样！

## 进制转换

- `0x`开头表示16进制，例如：0x2表示：2，0x2f表示48
- `0`开头表示8进制，例如：02表示：2,010表示：8
