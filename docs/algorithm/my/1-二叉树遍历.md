[参考labuladong](https://labuladong.gitee.io/algo/1/6/)

# 遍历框架

## 三个位置+边界条件

```java
void traverse(TreeNode root) {
   //最最重要的边界条件位置
    if (root == null) {
        return;
    }
    // 前序位置: 刚进入一个节点的时候（向下）
    traverse(root.left);
    // 中序位置：当前节点
    traverse(root.right);
    // 后序位置：即将离开一个节点的时候（向上）非常重要，可以通过子问题的答案得到父问题的答案！
}
```

<font color=red>注意，**三个位置**，不仅仅可以打印节点值来遍历，还可以注入其他逻辑实现不同算法。 我们只需要单独思考每一个节点，其之前、现在、之后的位置应该做什么，其他交给这个遍历框架</font>

<font color=red>遍历框架本身是一个递归函数,只是当问题只是打印节点值时不需要返回值！  一旦我们的问题需要有返回值，我们也可以让这个遍历框架中的递归函数有返回值，这个返回值就是问题的答案，递归函数的每次调用就是解决一个子问题。而后序位置可以通过子问题的答案得到父问题的答案</font>

<img src="https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image-20221124074913260.png" alt="image-20221124074913260" style="zoom:50%;" />

> 前序位置，向下进入某个节点，只能接受到参数的信息
>
> 中序位置，当前节点，能接收到参数和当前节点的信息
>
> 后序位置，向上离开某个节点，除了参数和节点信息外，还可以知道子问题的答案(两个红色箭头)

实际上， 它和遍历数组或者链表本质上是一样的

```java
/* 迭代遍历数组 */
void traverse(int[] arr) {
    for (int i = 0; i < arr.length; i++) {

    }
}

/* 递归遍历数组 */
void traverse(int[] arr, int i) {
    if (i == arr.length) {//遍历完了
        return;
    }
    // 前序位置
    traverse(arr, i + 1);
    // 后序位置
}

/* 迭代遍历单链表 */
void traverse(ListNode head) {
    for (ListNode p = head; p != null; p = p.next) {

    }
}

/* 递归遍历单链表 */
void traverse(ListNode head) {
    if (head == null) {
        return;
    }
    // 前序位置
    traverse(head.next);
    // 后序位置
}
```

## 后序位置很重要

从上面的图中，发现前序位置的代码执行是自顶向下的，而后序位置的代码执行是自底向上的，这意味着**前序位置的代码只能从函数参数中获取父节点传递来的数据，而后序位置的代码不仅可以获取参数数据，还可以获取到子树通过函数返回值传递回来的数据，也就是子问题的解**。

## 遍历过程中解决问题

<font color=red>思考： 遍历框架从根节点开始把二叉树每个节点遍历了一遍，遍历的同时通过外部变量记录和更新问题的答案 可以解决问题。   另外，分治思想下，通常用递归函数解决问题，考虑到递归框架本身也是一个递归函数，只是这个递归函数返回了空值, 它没有要解的问题，也不需要组织答案。我们是需要答案的，首先这个递归函数需要有返回值，其次，要思考如何组织子问题的答案得到原问题的答案；也就是在后序位置组织答案。对遍历框架中的递归函数进行修改即可。</font>

**就这么说吧，所有递归的算法，你甭管它是干什么的，本质上都是在遍历一棵（递归）树，然后在节点（前中后序位置）上执行代码，你要写递归算法，本质上就是要告诉每个节点需要做什么**。

所以，套路有三种：

1. **利用外部变量记录临时结果和答案**
2. **修改递归函数，使其返回子问题答案，在后序位置中组织原问题答案**
3. **以上两者组合**

例如：

```java
int maxDepth(TreeNode root) {//改成有返回值的递归函数
	if (root == null) {
		return 0;
	}
	int leftMax = maxDepth(root.left);
	int rightMax = maxDepth(root.right);
  //后序位置上组织子问题的解得到原问题的解
	int res = Math.max(leftMax, rightMax) + 1;
	return res;
}
```

**什么时候修改递归函数？ 一旦你发现题目和子树有关，那大概率要给函数设置合理的定义和返回值，在后序位置写代码了**。



# 两种思路

例如，[二叉树的最大深度](https://leetcode.cn/problems/maximum-depth-of-binary-tree/)，这个问题

##  **[回溯算法核心框架](https://labuladong.gitee.io/algo/4/31/104/)** ：遍历一遍

遍历一遍二叉树，如何得到最大深度呢？记录每个节点所在深度，取最大值即可

```java
// 记录最大深度
int res = 0;
// 记录遍历到的节点的深度
int depth = 0;

// 主函数
int maxDepth(TreeNode root) {
	traverse(root);
	return res;
}

// 二叉树遍历框架
void traverse(TreeNode root) {
	if (root == null) {
		return;
	}
	// 前序位置: 进入某个节点(向下)之前，更新深度，更新最大深度
	depth++;
    if (root.left == null && root.right == null) {
        // 到达叶子节点，更新最大深度
		res = Math.max(res, depth);
    }
	traverse(root.left);
	traverse(root.right);
	// 后序位置：离开某个节点(向上)，深度减一
	depth--;
}
```





## **[动态规划核心框架](https://labuladong.gitee.io/algo/3/25/69/)**：分解问题

二叉树最大深度这个问题，还可以通过子树的最大深度推导出来。主要是理解递归函数，这里主要逻辑放在后序位置上了，因为，原树的最大深度是在知道了子树深度的基础上算出来的。



```java
// 定义：输入根节点，返回这棵二叉树的最大深度
int maxDepth(TreeNode root) {
	if (root == null) {
		return 0;
	}
	// 利用定义，计算左右子树的最大深度
	int leftMax = maxDepth(root.left);
	int rightMax = maxDepth(root.right);
	// 组织原问题的答案： 整棵树的最大深度等于左右子树的最大深度取最大值，
    // 然后再加上根节点自己
	int res = Math.max(leftMax, rightMax) + 1;

	return res;
}

```

其实，分解法也可以解决遍历问题。

例如，前序遍历，**一棵二叉树的前序遍历结果 = 根节点 + 左子树的前序遍历结果 + 右子树的前序遍历结果**。

```java
// 定义：输入一棵二叉树的根节点，返回这棵树的前序遍历结果
List<Integer> preorderTraverse(TreeNode root) {
    List<Integer> res = new LinkedList<>();
    if (root == null) {
        return res;
    }
    // 前序遍历的结果，root.val 在第一个
    res.add(root.val);
    // 利用函数定义，后面接着左子树的前序遍历结果
    res.addAll(preorderTraverse(root.left));
    // 利用函数定义，最后接着右子树的前序遍历结果
    res.addAll(preorderTraverse(root.right));
    return res;
}
```

# 实战

## 二叉树最大直径

[二叉树的直径](https://leetcode.cn/problems/diameter-of-binary-tree/)

任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。

思考：一定要把问题分解，不能分解的先转化后再分解， 最大直径是某个节点左右子树的最大深度之和，于是，问题转化为求每个子树的最大深度，而用外部变量来记录同一个节点的左右子树最大深度之和。

所以，递归函数的返回值是树的最大深度，算出左右子树的最大深度后，在后序位置，组织当前节点的最大深度，即子树最大深度+1； 顺便，我们利用外部变量保存原问题的答案并更新之。

<img src="https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image-20221124100047689.png" alt="image-20221124100047689" style="zoom:50%;" />

```java
// 记录最大直径的长度
int maxDiameter = 0;

public int diameterOfBinaryTree(TreeNode root) {
    maxDepth(root);
    return maxDiameter;
}

int maxDepth(TreeNode root) {
    if (root == null) {
        return 0;
    }
    int leftMax = maxDepth(root.left);
    int rightMax = maxDepth(root.right);
    // 后序位置，顺便计算最大直径
    int myDiameter = leftMax + rightMax;
    maxDiameter = Math.max(maxDiameter, myDiameter);

    return 1 + Math.max(leftMax, rightMax);//组织子问题的解，得到当前节点的最大深度
}
```

# 层序遍历

## 遍历框架

核心思想： 用队列保存需要遍历的子树的根节点；依次遍历这些根节点： 取出并把其左右子节点入队。

```java
// 输入一棵二叉树的根节点，层序遍历这棵二叉树
void levelTraverse(TreeNode root) {
    if (root == null) return;
    Queue<TreeNode> q = new LinkedList<>();
    q.offer(root);

    while (!q.isEmpty()) {
        int sz = q.size();
        // 遍历当前队列
        for (int i = 0; i < sz; i++) {
            TreeNode cur = q.poll();//当前节点出队
          // 位置3:弹出后
            // 将下一层节点放入队列
            if (cur.left != null) {
            // 位置1:入队前
                q.offer(cur.left);
             // 位置2:入队后
            }
            if (cur.right != null) {
                q.offer(cur.right);
            }
        }
    }
}
```

