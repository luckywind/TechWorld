# HJ27查找兄弟单词

## 总结

1. 在 ASCII 编码中，英文字母的编码范围如下：

- **大写字母 A 到 Z：** 对应的 ASCII 码从 65 到 90。`ch-'A'`的范围是[0-25]
- **小写字母 a 到 z：** 对应的 ASCII 码从 97 到 122。`ch-'a'`的范围是[0,25]

2. 对List排序： Collections.sort(list); 

3. next()读取一个单词，nextInt()、nextLine()

4. 忽略字母顺序的小写字母字符串比较

   ```java
       public static boolean checkBorther(String str1, String str2){
           int[] arr = new int[26];//因为全是小写字母，所以26足够
           char[] ch1 = str1.toCharArray();
           char[] ch2 = str2.toCharArray();
           for(int i=0; i<ch1.length; i++){
               arr[ch1[i]-'a']++; /
               arr[ch2[i]-'a']--;
           }
           for(int i=0; i<26; i++){
               if(arr[i]!=0)
                   return false;
           }
           return true;
       }
   ```

   

这个题告诉我们一定要理解题意，多读几遍。。。

## 描述

定义一个由**小写字母**构成的字符串 *s* 的“兄弟单词”为：**任意交换** *s* 中两个字母的位置，得到的新字符串，且其与 *s* 不同。
现在，对于给定的 n* 个字符串 s1​,*s*2​,…,*s**n*​ 和另一个单独的字符串 x* ，你需要解决两个问题：
∙ ∙统计这 n* 个字符串中，有多少个是 x* 的“兄弟单词”；
∙ ∙将这 n* 个字符串中 *x* 的“兄弟单词”按字典序从小到大排序，输出排序后的第 *k* 个兄弟单词。特别地，如果不存在，则不输出任何内容。

从字符串的第一个字符开始逐个比较，直到找到第一个不同的位置，通过比较这个位置字符的字母表顺序得出字符串的大小，称为字典序比较。

### 输入描述：

在一行上：
1. 1.​先输入一个整数nn*(1≦*n*≦1000) 代表字符串的个数；
2. 2.​随后，输入 n个长度为 1≦length(si)≦10 ，仅由小写字母构成的字符串`s*1​,*s*2​,…,s*n​ `；
3. 3.​随后，输入一个字符串 x ；
4. 4.​最后，输入一个整数 k*(1≦*k*≦*n*) 代表要查找的兄弟单词的序号。

### 输出描述：

第一行输出一个整数，代表给定的 *n* 个字符串中，*x* 的“兄弟单词”的数量；
第二行输出一个字符串，代表将给定的 *n* 个字符串中 x* 的“兄弟单词”按字典序排序后的第 k* 小兄弟单词。特别地，如果不存在，则不输出任何内容。

<font color=red>checkBorther非常巧妙： 完成忽略字母顺序的小写字母字符串比较</font>

> char-'a'则变成一个0-25的数字

```java
import java.util.*;
public class Main{
    public static boolean checkBorther(String str1, String str2){
        int[] arr = new int[26];//因为全是小写字母，所以26足够
        char[] ch1 = str1.toCharArray();
        char[] ch2 = str2.toCharArray();
        for(int i=0; i<ch1.length; i++){
            arr[ch1[i]-'a']++; /
            arr[ch2[i]-'a']--;
        }
        for(int i=0; i<26; i++){
            if(arr[i]!=0)
                return false;
        }
        return true;
    }

    public static void main(String[] args){
        Scanner sc = new Scanner(System.in);
        while(sc.hasNext()){
            int N = sc.nextInt(); //输入字典中单词的个数
            String[] str = new String[N];
            for(int i=0; i<N; i++){ //输入n个单词作为字典单词
                str[i]=sc.next();
            }
            // 查找兄弟单词
            String findStr = sc.next();//输入一个待查单词
            int ind = sc.nextInt(); //输入待查单词的 指定序号     
            ArrayList<String> list = new ArrayList<>();
            for(int i=0; i<N; i++){
               if((str[i].length() == findStr.length()) && (!str[i].equals(findStr))){//长度相等 且 字符串不相等
                    if(checkBorther(findStr,str[i])){
                        list.add(str[i]);
                    }
                }
            }
            //输出 
            System.out.println(list.size());     
            Collections.sort(list);
            if(list.size()>=ind){
                System.out.println(list.get(ind-1));  
            }
        }
    }
}
```

# [HJ29字符串加解密](https://www.nowcoder.com/practice/2aa32b378a024755a3f251e75cbf233a?tpId=37&tags=&title=&difficulty=3&judgeStatus=&rp=1&sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&gioEnter=menu)

## 总结

1. 大小写转换: 例如小写转大写

   ```java
             if(t[i]>='a' && t[i]<'z')
                   t[i] = (char)(t[i] - 'a' + 'A' + 1);
   ```

2. `String.valueOf(char[])`

## code

```java
import java.util.Scanner;

public class Main{
    public static void main(String[] args){
        Scanner in = new Scanner(System.in);
        while(in.hasNext()){
            System.out.println(encode(in.nextLine()));
            System.out.println(decode(in.nextLine()));
        }
    }

    //加密函数
    private static String encode(String code){
        char[] t = code.toCharArray();    //将String对象转换为字符数组
        for(int i=0; i < t.length; i++){
            if(t[i]>='a' && t[i]<'z')
                t[i] = (char)(t[i] - 'a' + 'A' + 1);
            else if(t[i] == 'z')
                t[i] = 'A';
            else if(t[i]>='A' && t[i]<'Z')
                t[i] = (char)(t[i] - 'A' + 'a' + 1);
            else if(t[i] == 'Z')
                t[i] = 'a';
            else if(t[i]>='0' && t[i]<'9')
                t[i] = (char)(t[i]+1);
            else if(t[i] == '9')
                t[i] = '0';
        }
        return String.valueOf(t);
    }

    //解密函数
    private static String decode(String password){
        char[] t = password.toCharArray();
        for(int i=0; i < t.length; i++){
            if(t[i]>'a' && t[i]<='z')
                t[i] = (char)(t[i] - 'a' + 'A' - 1);
            else if(t[i] == 'a')
                t[i] = 'Z';
            else if(t[i]>'A' && t[i]<='Z')
                t[i] = (char)(t[i] - 'A' + 'a' - 1);
            else if(t[i] == 'A')
                t[i] = 'z';
            else if(t[i]>'0' && t[i]<='9')
                t[i] = (char)(t[i]-1);
            else if(t[i] == '0')
                t[i] = '9';
        }
        return String.valueOf(t);
    }
}
```

# **HJ59** **找出字符串中第一个只出现一次的字符

描述

对于给定的字符串，找出第一个只出现一次的字符。如果不存在，则输出 −1−1。

输入描述：

在一行上输入一个长度为 1≦len(*s*)≦10^3、仅由小写字母构成的字符串 *s*。

输出描述：

如果存在只出现一次的字符，输出第一个满足条件的字符；否则，直接输出−1。

## code

```java
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        String str=in.nextLine();
        char[] arr=str.toCharArray();
        int[]cnt=new int[26];
        for(char ch:arr){
            cnt[ch-'a']++;
        }
        boolean found=false;
        for(char ch:arr){
            if(cnt[ch-'a']==1){ //ch的计数为1
                System.out.println(ch);
                found=true;
                break;
            }
        }

        if(!found){
        System.out.println(-1);
        }

    }
}
```

# H16[购物单](https://www.nowcoder.com/practice/f9c6f980eeec43ef85be20755ddbeaf4?tpId=37&tags=&title=&difficulty=3&judgeStatus=&rp=1&sourceUrl=%2Fexam%2Foj%2Fta%3FtpId%3D37&gioEnter=menu)

## 总结

1. 二维数组的声明必须写明各个纬度。

![image-20250314145920948](https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image-20250314145920948.png)

```java
import java.util.*;
public class Main {
        public static void main(String[] args) {
            Scanner sc = new Scanner(System.in);
            while (sc.hasNextLine()) {
                int money = sc.nextInt();
                int m = sc.nextInt();
                sc.nextLine();
                money /= 10;
                int[][] prices = new int[m+1][3];
                int[][] weights = new int[m+1][3];
                for (int i = 1; i <= m; i++) {
                    int a = sc.nextInt();
                    int b = sc.nextInt();
                    int c = sc.nextInt();
                    a /= 10;//price
                    b = b * a;//weight
                    if (c == 0) {
                        // 主件
                        prices[i][0] = a;
                        weights[i][0] = b;
                    } else if (prices[c][1] == 0) {
                        // 附件1
                        prices[c][1] = a;
                        weights[c][1] = b;
                    } else {
                        // 附件2
                        prices[c][2] = a;
                        weights[c][2] = b;
                    }
                    sc.nextLine();
                }
                int[][] dp = new int[m+1][money+1];
                for (int i = 1; i <= m; i++) {
                    for(int j = 1; j <= money; j++) {
                       //主件
                        int a = prices[i][0];
                        int b = weights[i][0];
                      // 附件1
                        int c = prices[i][1];
                        int d = weights[i][1];
                      // 附件2
                        int e = prices[i][2];
                        int f = weights[i][2];
                       //下面用四种情况去优化已有数据，
                        dp[i][j] = j - a >= 0 ? Math.max(dp[i-1][j], dp[i-1][j-a] + b) : dp[i-1][j];//只买主件，无法买则只能继承
                        dp[i][j] = j-a-c >= 0 ? Math.max(dp[i][j], dp[i-1][j-a-c] + b + d):dp[i][j];//主件+附件1，继续优化
                        dp[i][j] = j-a-e >= 0 ? Math.max(dp[i][j], dp[i-1][j-a-e] + b + f):dp[i][j];//主件+附件2，继续优化
                        dp[i][j] = j-a-c-e >= 0 ? Math.max(dp[i][j], dp[i-1][j-a-c-e] + b +d + f):dp[i][j];//主件+附件1，2，继续优化
                    }
                }
                
                System.out.println(dp[m][money] * 10);
            }
        }
}

```

# HJ36字符串加密

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        String src=in.nextLine();
        char[] a=src.toCharArray(); //输入字符序列
        char[] x=new char[26];
        int[] id=new int[26]; //记录每个字母是否已出现
        int ix=0;
        for(char ch:a){ 
            if(id[ch-'a']>0){ //已出现
                continue;
            }else{
                id[ch-'a']++;
                x[ix++]=ch; //不重复的字符放到x里
            }
        }
        //接下来要把未出现过的字母依次放入x
        for(int i=0;i<26;i++){
            if(id[i]==0){ // i+'a' 未出现
                x[ix++] = (char)(i+'a' ); 
            }
        }

        // 至此x 是s构建的字母表
        char[] input=in.nextLine().toCharArray();
        char[] res=new char[input.length];
        for(int i=0;i<input.length;i++){
          int idx=  input[i]-'a'; //正常序号
          res[i] = x[idx]; //加密后
        }
        System.out.println(String.valueOf(res));
    }
}
```

# HJ32密码截取(最长回文子串)

![image-20250314180031524](https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image-20250314180031524.png)

```java
import java.io.BufferedReader;
import java.io.IOException;
import java.io.InputStreamReader;

public class Main {
    public static void main(String[] args) throws IOException {
        BufferedReader br = new BufferedReader(new InputStreamReader(System.in));
        String s = "";
        while ((s = br.readLine()) != null) {
            System.out.println(validLen(s));
        }
        br.close();
    }

    public static int validLen(String s) {
        int len = s.length();
        // 状态：对比的两个字符索引起始和终止索引位置
        // 定义: 字符串s的i到j字符组成的子串是否为回文子串
        boolean[][] dp = new boolean[len][len];
        int res = 0;
        // base case
        for(int i = 0; i < len - 1; i++) {
            dp[i][i] = true;
        }

        for(int r = 1; r < len; r++) {
            for(int l = 0; l < r; l++) {
                // 状态转移：如果左右两字符相等,同时[l+1...r-1]范围内的字符是回文子串
                // 则 [l...r] 也是回文子串
                if(s.charAt(l) == s.charAt(r) && (r-l <= 2 || dp[l+1][r-1])) {
                    dp[l][r] = true;
                    // 不断更新最大长度
                    res = Math.max(res, r - l + 1);
                } 
            }
        }
        return res;
    }
}

```

- r-l<=2对应A和AA这种类型的回文子串（因为第一个条件限制了两端相等）
- 注意遍历顺序

# HJ33整数转IP地址

**8位二进制最大值是256**

描述

原理：ip地址的每段可以看成是一个0-255的整数，把每段拆分成一个二进制形式组合起来，然后把这个二进制数转变成
一个长整数。
举例：一个ip地址为10.0.3.193
每段数字       相对应的二进制数
10          00001010
0          00000000
3          00000011
193         11000001

组合起来即为：00001010 00000000 00000011 11000001,转换为10进制数就是：167773121，即该IP地址转换后的数字就是它了。

数据范围：保证输入的是合法的 IP 序列

输入描述：

输入 
1 输入IP地址
2 输入10进制型的IP地址

输出描述：

输出
1 输出转换成10进制的IP地址
2 输出转换后的IP地址

```java
import java.util.*;

public class Main {

    private final int N = 4;
    public Main() {
    }

    public String convert(String str) {
        // ipv4 -> int
        if (str.contains(".")) {
            String[] fields = str.split("\\.");
            long result = 0;
            for (int i = 0; i < N; i++) {
                result = result * 256 + Integer.parseInt(fields[i]);
            }
            return "" + result;
        }
        // int -> ipv4
        else {
            long ipv4 = Long.parseLong(str);
            String result = "";
            for (int i = 0; i < N; i++) {
                result = ipv4 % 256 + "." + result;
                ipv4 /= 256;
            }
            return result.substring(0, result.length() - 1);
        }
    }

    public static void main(String[] args) {
        Main solution = new Main();
        Scanner in = new Scanner(System.in);
        while (in.hasNext()) {
            String str = in.next();
            String res = solution.convert(str);
            System.out.println(res);
        }
    } 
}
```



# **HJ38** **求小球落地5次后所经历的路程和第5次反弹的高度**

核心在于定义清除变量

![image-20250317100243174](https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image-20250317100243174.png)

```java
import java.util.Scanner;

// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        double h=in.nextDouble();
        double res=h;//路程
        double s=2*h; //一个来回的路程
        double th=0.5*h; //第一次反弹的高度，并非初始高度
        for(int i=2;i<=5;i++){
            s=0.5*s; //路程减半
            res+=s; // 更新总路程
            th/=2.0;  //高度减半
        }
        System.out.println(res);
        System.out.println(th);

    }
}
```

# HJ41称砝码

![image-20250318085138383](https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image-20250318085138383.png)

```java
import java.util.Scanner;
import java.util.*;
// 注意类名必须为 Main, 不要有任何 package xxx 信息
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别

        int n = in.nextInt();
        int[] w=new int[n];
        int[] m=new int[n];
        for(int i=0;i<n;i++){
            w[i]=in.nextInt(); //每个砝码的重量
        }
        for(int i=0;i<n;i++){
            m[i]=in.nextInt();//砝码个数
        }
       
        HashSet<Integer> set = new HashSet<>();//存放所有可能的结果
        set.add(0);//这个非常重要，它保证了当前组合可以直接进入set，而不用与之前的重量累加。
        for(int i=0;i<n;i++){ //以此添加不同重量的砝码
            ArrayList<Integer> list=new ArrayList<>(set);//取已有结果
            //现在添加重量为w[i]的砝码
            for(int j=1;j<=m[i];j++){ //遍历当前砝码所有个数
               //j为当前砝码的个数
               // w[i] * j 为当前组合的重量和
               for(int k=0;k<list.size();k++){ //遍历所有结果
                    set.add(list.get(k) + w[i]*j); //与已有结果组合
               }

            }

        }
    System.out.println(set.size());
    }
}
```

# HJ43迷宫问题

![image-20250318085744272](https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image-20250318085744272.png)

## code

```java
import java.util.*;
// 题目已经提示了 【迷宫只有一条通道】，则直接使用 DFS 找路径就行了，如不有多条路径找最短考虑使用 BFS
public class Main {
    public static void main(String[] args) {
        Scanner in = new Scanner(System.in);
        // 注意 hasNext 和 hasNextLine 的区别
        while (in.hasNextInt()) { // 注意 while 处理多个 case
            int n = in.nextInt();
            int m = in.nextInt();
            // 构造迷宫
            int[][] map = new int[n][m];
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < m; j++) {
                    map[i][j] = in.nextInt();
                }
            }
            
            // 路径存储的数组
            List<Pos> path = new ArrayList<>();
            // DFS 搜索路径
            dfs(map, 0, 0, path);
            // 输出
            for (Pos p : path) {
                System.out.println("(" + p.x + "," + p.y + ")");
            }
        }
    }
    
    // 返回值 标记是否找到可通行的路劲
    public static boolean dfs(int[][] map, int x, int y, List<Pos> path) {
        // 添加路径并标记已走
        path.add(new Pos(x, y));
        map[x][y] = 1;
        // 结束标志
        if (x == map.length - 1 && y == map[0].length - 1) {
            return true;
        }
        // 向下能走时
        if (x + 1 < map.length && map[x + 1][y] == 0) {
            if (dfs(map, x + 1, y, path)) {
                return true;
            }
        }
        // 向右能走时
        if (y + 1 < map[0].length && map[x][y + 1] == 0) {
            if (dfs(map, x, y + 1, path)) {
                return true;
            }
        }
        // 向上能走时
        if (x - 1 > -1 && map[x - 1][y] == 0) {
            if (dfs(map, x - 1, y, path)) {
                return true;
            }
        }
        // 向左能走时
        if (y - 1 > -1 && map[x][y - 1] == 0) {
            if (dfs(map, x, y - 1, path)) {
                return true;
            }
        }
        // 回溯
        path.remove(path.size() - 1);
        map[x][y] = 0;
        return false;
    }
    
    // 简单的位置类
    public static class Pos {
        int x;
        int y;
        
        public Pos(int x, int y) {
            this.x = x;
            this.y = y;
        }
    }
}

```

