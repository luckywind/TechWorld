[参考](https://juejin.cn/post/6951922898638471181)

# 核心思想

动态规划最核心的思想，就在于**拆分子问题，记住过往，减少重复计算**。

<img src="https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image/image-20210805100825103.png" alt="image-20210805100825103" style="zoom:50%;" />

## 青蛙跳问题

### 暴力递归

leetcode原题：一只青蛙一次可以跳上1级台阶，也可以跳上2级台阶。求该青蛙跳上一个 10 级的台阶总共有多少种跳法。

可以这么想：

>  - 要想跳到第10级台阶，要么是先跳到第9级f(9)，然后再跳1级台阶上去;要么是先跳到第8级f(8)，然后一次迈2级台阶上去。两者是不同的方式簇，所以直接相加。
>  - 同理，要想跳到第9级台阶，要么是先跳到第8级，然后再跳1级台阶上去;要么是先跳到第7级，然后一次迈2级台阶上去。
>  - 要想跳到第8级台阶，要么是先跳到第7级，然后再跳1级台阶上去;要么是先跳到第6级，然后一次迈2级台阶上去。

假设跳到第n级台阶的跳数我们定义为f(n)，很显然就可以得出以下公式：

```shell
f（10） = f（9）+f(8)  这里一定要想清楚啊，为啥是这样！！！
f (9)  = f(8) + f(7)
f (8)  = f(7) + f(6)
...
f(3) = f(2) + f(1)

即通用公式为: f(n) = f(n-1) + f(n-2)
```

那f(2) 或者 f(1) 等于多少呢？

- 当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即f(2) = 2;
- 当只有1级台阶时，只有一种跳法，即f（1）= 1；

因此可以用递归去解决这个问题：

```java
class Solution {
    public int numWays(int n) {
    if(n == 1){
        return 1;
    }
     if(n == 2){
        return 2;
    }
    return numWays(n-1) + numWays(n-2);
    }
}
```

时间复杂度

```
递归时间复杂度 = 解决一个子问题时间*子问题个数
```

- 一个子问题时间 =  f（n-1）+f（n-2），也就是一个加法的操作，所以复杂度是 O(1)；
- 问题个数 = 递归树节点的总数，递归树的总节点 = 2^n-1，所以是复杂度O(2^n)。

因此，青蛙跳阶，递归解法的时间复杂度 = O(1) * O(2^n) =  O(2^n)，就是指数级别的，爆炸增长的，如果n比较大的话，超时很正常的了。

回过头来，你仔细观察这颗递归树，你会发现存在大量重复计算，比如f（8）被计算了两次，f（7）被重复计算了3次...所以这个递归算法低效的原因，就是**存在大量的重复计算**！

既然存在大量重复计算，那么我们可以先把计算好的答案存下来，即造一个备忘录，等到下次需要的话，先去备忘录查一下，如果有，就直接取就好了，备忘录没有才开始计算，那就可以省去重新重复计算的耗时啦！这就是带备忘录的解法。

### 备忘录递归(自顶向下)

```java
public class Solution {
    //使用哈希map，充当备忘录的作用
    Map<Integer, Integer> tempMap = new HashMap();
    public int numWays(int n) {
        // n = 0 也算1种
        if (n == 0) {
            return 1;
        }
        if (n <= 2) {
            return n;
        }
        //先判断有没计算过，即看看备忘录有没有
        if (tempMap.containsKey(n)) {
            //备忘录有，即计算过，直接返回
            return tempMap.get(n);
        } else {
            // 备忘录没有，即没有计算过，执行递归计算,并且把结果保存到备忘录map中，对1000000007取余（这个是leetcode题目规定的）
            tempMap.put(n, (numWays(n - 1) + numWays(n - 2)) % 1000000007);
            return tempMap.get(n);
        }
    }
}

```

### 动态规划(自底向上)

- 带备忘录的递归，是从f(10)往f(1）方向延伸求解的，所以也称为**自顶向下**的解法。
- 动态规划从较小问题的解，由交叠性质，逐步决策出较大问题的解，它是从f(1)往f(10）方向，往上推求解，所以称为**自底向上**的解法。

动态规划有几个典型特征，**最优子结构、状态转移方程、边界、重叠子问题**。在青蛙跳阶问题中：

- f(n-1)和f(n-2) 称为 f(n) 的最优子结构
- f(n)= f（n-1）+f（n-2）就称为状态转移方程
- f(1) = 1, f(2) = 2 就是边界啦
- 比如f(10)= f(9)+f(8),f(9) = f(8) + f(7) ,f(8)就是重叠子问题。

我们来看下自底向上的解法，从f(1)往f(10）方向，想想是不是直接一个for循环就可以解决啦，如下：


```java
public class Solution {
    public int numWays(int n) {
        if (n<= 1) {
            return 1;
        }
        if (n == 2) {
            return 2;
        }
        int a = 1;
        int b = 2;
        int temp = 0;
        for (int i = 3; i <= n; i++) {
            temp = (a + b)% 1000000007;
            a = b;
            b = temp;
        }
        return temp;
    }
    }

```



# 动态规划解题思路

动态规划的核心思想就是**拆分子问题，记住过往，减少重复计算。** 并且动态规划一般都是自底向上的，因此到这里，基于**青蛙跳阶**问题，我总结了一下我做动态规划的思路：

- 穷举分析
- 确定边界
- 找出规律，确定最优子结构
- 写出状态转移方程

##  穷举分析

原问题是否跟子问题有关？关系是啥？

1. 当台阶数是1的时候，有一种跳法，f（1） =1
2. 当只有2级台阶时，有两种跳法，第一种是直接跳两级，第二种是先跳一级，然后再跳一级。即f(2) = 2;
3. 当台阶是3级时，想跳到第3级台阶，要么是先跳到第2级，然后再跳1级台阶上去，要么是先跳到第 1级，然后一次迈 2 级台阶上去。所以f(3) = f(2) + f(1) =3
4. 当台阶是4级时，想跳到第3级台阶，要么是先跳到第3级，然后再跳1级台阶上去，要么是先跳到第 2级，然后一次迈 2 级台阶上去。所以f(4) = f(3) + f(2) =5
5. 当台阶是5级时......



##  确定边界

通过穷举分析，我们发现，当台阶数是1的时候或者2的时候，可以明确知道青蛙跳法。f（1） =1，f(2) = 2，当台阶n>=3时，已经呈现出规律f(3) = f(2) + f(1) =3，因此f（1） =1，f(2) = 2就是青蛙跳阶的边界。

##  找出规律，确定最优子结构

n>=3时，已经呈现出规律 f(n) = f(n-1) + f(n-2) ，因此，f(n-1)和f(n-2) 称为 f(n) 的最优子结构。什么是最优子结构？有这么一个解释：

> 一道动态规划问题，其实就是一个递推问题。假设当前决策结果是f(n),则最优子结构就是要让 f(n-k) 最优,最优子结构性质就是能让转移到n的状态是最优的,并且与后面的决策没有关系,即让后面的决策安心地使用前面的局部最优解的一种性质



##  写出状态转移方程

![image-20210805102746727](https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image/image-20210805102746727.png)

## 代码实现

我们实现代码的时候，一般注意从底往上遍历哈，然后关注下边界情况，空间复杂度，也就差不多啦。动态规划有个框架的，大家实现的时候，可以考虑适当参考一下：

```java
dp[0][0][...] = 边界值
for(状态1 ：所有状态1的值){
    for(状态2 ：所有状态2的值){
        for(...){
          //状态转移方程
          dp[状态1][状态2][...] = 求最值
        }
    }
}

```

# 最长严格递增子序列的长度

给你一个整数数组 nums ，找到其中最长严格递增子序列的长度。

```
dp(i) =max(dp(j))+1，存在j属于区间[0，i-1],并且num[i]>num[j]。
dp(i) = 1 , 不存在j属于区间[0，i-1],并且num[i]>num[j]。
```





# 其他博客

## [动态规划：从新手到专家](https://hawstein.com/2013/03/26/dp-novice-to-advanced/)

## [labuladong 深度好文：动态规划详解](https://www.cnblogs.com/labuladong/p/12320371.html)

## [图解算法——动态规划系列](https://www.infoq.cn/article/qigxptpf3ix7opcht1gp)

### 最大子序和

**题目：给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。**

首先我们分析题目，一个连续子数组一定要以一个数作为结尾，那么我们可以将状态定义成如下：

> dp[i]：表示以 nums[i] 结尾的连续子数组的最大和。

那么为什么这么定义呢？因为这样定义其实是最容易想到的！在上一节中我们提到，状态转移方程其实是通过 1-3 个参数的方程来描述小规模问题和大规模问题间的关系。

如果要得到 dp[i]，那么 nums[i]一定会被选取。并且 dp[i] 所表示的连续子序列与 dp[i-1] 所表示的连续子序列很可能就差一个 nums[i] 。即



> dp[i] = dp[i-1]+nums[i] , if (dp[i-1] >= 0)



但是这里我们遇到一个问题，**很有可能 dp[i-1]本身是一个负数。那这种情况的话，如果 dp[i]通过 dp[i-1]+nums[i]来推导，那么结果其实反而变小了，因为我们 dp[i]要求的是最大和**。所以在这种情况下，如果 dp[i-1]<0，那么 dp[i]其实就是 nums[i]的值。即



> dp[i] = nums[i] , if (dp[i-1] < 0)

综上分析，我们可以得到：



> dp[i]=max(nums[i], dp[i−1]+nums[i])

得到了状态转移方程，但是我们还需要通过一个已有的状态的进行推导，我们可以想到 **dp[0] 一定是以 nums[0] 进行结尾**，所以



> dp[0] = nums[0]

在很多题目中，因为 dp[i]本身就定义成了题目中的问题，所以 dp[i]最终就是要的答案。但是这里状态中的定义，并不是题目中要的问题，不能直接返回最后的一个状态 (这一步经常有初学者会摔跟头)。所以最终的答案，其实我们是寻找：

> max(dp[0], dp[1], …, d[i-1], dp[i])



#### 代码

```java
  public int maxSubArray(int[] nums) {
    if (nums.length == 1) {
      return nums[0];
    }

    int dp=nums[0];
    int res = dp;
    for (int i = 1; i < nums.length; i++) {
      dp = Math.max(dp + nums[i], nums[i]);
      res = Math.max(res, dp);
    }
    return res;
  }
```







# 总结

<font color='red'>一定要仔细定义状态、状态定义的越清晰，后续状态转移就越简单</font>

