[参考](https://labuladong.github.io/algo/1/7/)

**动态规划问题的一般形式就是求最值**,动态规划其实是运筹学的一种最优化方法，**核心问题是穷举**。

虽然动态规划的核心思想就是穷举求最值，但是问题可以千变万化，穷举所有可行解其实并不是一件容易的事，需要你熟练掌握递归思维，只有列出**正确的「状态转移方程」**，才能正确地穷举。而且，你需要判断算法问题是否**具备「最优子结构」**，是否能够通过子问题的最值得到原问题的最值。另外，动态规划问题**存在「重叠子问题」**，如果暴力穷举的话效率会很低，所以需要你使用「备忘录」或者「DP table」来优化穷举过程，避免不必要的计算。

以上提到的

1. **状态转移方程**：从子问题的解如何得到原问题的解

2. **重叠子问题**： 用于优化，备忘录避免重复计算;  <font color=red>注意先进行边界条件，再查备忘录,否则可能备忘录索引越界</font>

3. **最优子结构**： 子问题的解相互独立

   就是动态规划三要素

# 代码框架套路

1. 自顶向下的递归解法
   <font color=red>dp函数：参数是状态，返回值是解</font>

   ```java
   # 自顶向下递归的动态规划
   def dp(状态1, 状态2, ...):
       for 选择 in 所有可能的选择:
           # 此时的状态已经因为做了选择而改变
           result = 求最值(result, dp(状态1, 状态2, ...))
       return result
   ```

   

2. 自底向上递推的解法
   <font color=red>dp数组：参数是索引，值是解</font>

   > 有时候，值是中间解，最终解基于中间解取最大；所以要对问题进行转化

   ```java
   # 自底向上迭代的动态规划
   # 初始化 base case
   dp[0][0][...] = base case
   # 进行状态转移
   for 状态1 in 状态1的所有取值：
       for 状态2 in 状态2的所有取值：
           for ...
               dp[状态1][状态2][...] = 求最值(选择1，选择2...)
   ```

   



# 状态转移方程

它是解决问题的核心，而且很容易发现，其实状态转移方程直接代表着暴力解法。**千万不要看不起暴力解，动态规划问题最困难的就是写出这个暴力解，即状态转移方程**。只要写出暴力解，优化方法无非是用备忘录或者 DP table，再无奥妙可言。

斐波那契数列的计算： 

1. 自顶向下暴力递归

   ```java
   int fib(int N) {     //第N项值只跟N有关系，所以状态只有N
       if (N == 1 || N == 2) return 1;
       return fib(N - 1) + fib(N - 2);    //状态转移方程
   }
   ```

   优化：使用备忘录

   ```java
   int fib(int N) {
       // 备忘录全初始化为 0
       int[] memo = new int[N + 1];
       // 进行带备忘录的递归
       return helper(memo, N);
   }
   
   int helper(int[] memo, int n) {
       // base case
       if (n == 0 || n == 1) return n;
       // 已经计算过，不用再计算了
       if (memo[n] != 0) return memo[n];
       memo[n] = helper(memo, n - 1) + helper(memo, n - 2);
       return memo[n];
   }
   ```

   

2. 自底向上递推

```java
int fib(int N) {
    if (N == 0) return 0;
    int[] dp = new int[N + 1];
    // base case
    dp[0] = 0; dp[1] = 1;

    for (int i = 2; i <= N; i++) {//遍历这个状态的所有取值
        dp[i] = dp[i - 1] + dp[i - 2];    // 状态转移方程
    }

    return dp[N];
}
```

这个递推解法的复杂度和带备忘录的递归解法类似

进一步优化：不保留全部的备忘录，只保留下一个状态需要的数据

```java
int fib(int n) {
    if (n == 0 || n == 1) {
        // base case
        return n;
    }
    // 分别代表 dp[i - 1] 和 dp[i - 2]
    int dp_i_1 = 1, dp_i_2 = 0;
    for (int i = 2; i <= n; i++) {
        // dp[i] = dp[i - 1] + dp[i - 2];
        int dp_i = dp_i_1 + dp_i_2;
        // 滚动更新
        dp_i_2 = dp_i_1;
        dp_i_1 = dp_i;
    }
    return dp_i_1;
}
```



# 最优子结构

子问题间是独立的

例如：总成绩是各科成绩之和，各科成绩之间相互独立，则总成绩具有最优子结构

## 凑零钱问题

给你 `k` 种面值的硬币，面值分别为 `c1, c2 ... ck`，每种硬币的数量无限，再给一个总金额 `amount`，问你**最少**需要几枚硬币凑出这个金额，如果不可能凑出，算法返回 -1 。算法的函数签名如下：

```java
// coins 中是可选硬币面值，amount 是目标金额
int coinChange(int[] coins, int amount);
```

​        首先这是一个具有最优子结构的问题：
假设你有面值为 `1, 2, 5` 的硬币，你想求 `amount = 11` 时的最少硬币数（原问题），如果你知道凑出 `amount = 10, 9, 6` 的最少硬币数（子问题），你只需要把子问题的答案加一（再选一枚面值为 `1, 2, 5` 的硬币），求个最小值，就是原问题的答案。因为硬币的数量是没有限制的，所以子问题之间没有相互制，是互相独立的。

### 自顶向下递归解法     

**1、确定 base case**，这个很简单，显然目标金额 `amount` 为 0 时算法返回 0，因为不需要任何硬币就已经凑出目标金额了。

**2、确定「状态」，也就是原问题和子问题中会变化的变量**。由于硬币数量无限，硬币的面额也是题目给定的，只有目标金额会不断地向 base case 靠近，所以唯一的「状态」就是目标金额 `amount`。

**3、确定「选择」所有的选项，也就是导致「状态」产生变化的行为**。目标金额为什么变化呢，因为你在选择硬币，你每选择一枚硬币，就相当于减少了目标金额。所以说所有硬币的面值，就是你的「选择」。

**4、明确 `dp` 函数/数组的定义**。我们这里讲的是自顶向下的解法，所以会有一个递归的 `dp` 函数，一般来说函数的参数就是状态转移中会变化的量，也就是上面说到的「状态」；函数的返回值就是题目要求我们计算的量。就本题来说，状态只有一个，即「目标金额」，题目要求我们计算凑出目标金额所需的最少硬币数量。

**所以我们可以这样定义 `dp` 函数：`dp(n)` 表示，输入一个目标金额 `n`，返回凑出目标金额 `n` 所需的最少硬币数量**。

```java
// 伪码框架
int coinChange(int[] coins, int amount) {
    // 题目要求的最终结果是 dp(amount)
    return dp(coins, amount)
}

// 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币
int dp(int[] coins, int n) {
    // 做选择，选择需要硬币最少的那个结果；  有多个子问题，这些子问题的解加1(块硬币)就是原问题的解。
    for (int coin : coins) {
        res = min(res, 1 + dp(n - coin))  //状态转移方程
    }
    return res
}

```

再加上边界条件

```java
int coinChange(int[] coins, int amount) {
    // 题目要求的最终结果是 dp(amount)
    return dp(coins, amount)
}

// 定义：要凑出金额 n，至少要 dp(coins, n) 个硬币
int dp(int[] coins, int amount) {
    // base case
    if (amount == 0) return 0;
    if (amount < 0) return -1;

    int res = Integer.MAX_VALUE;
    for (int coin : coins) {
        // 计算子问题的结果
        int subProblem = dp(coins, amount - coin);
        // 子问题无解则跳过
        if (subProblem == -1) continue;
        // 在子问题中选择最优解，然后加一
        res = Math.min(res, subProblem + 1);
    }

    return res == Integer.MAX_VALUE ? -1 : res;//⚠️：这里必须把最大值替换掉，否则下次迭代使用这个res+1会导致溢出。
}

```

这是暴力递归的解法，会有很多重叠子问题，至于优化，当然也可以用备忘录优化。

```java
public class CoinChange {
  int[] mem=null;

  public static void main(String[] args) {
    CoinChange change = new CoinChange();
    int res = change.coinChange(new int[]{2}, 3);
    System.out.println(res);
  }
  public int coinChange(int[] coins, int amount) {
    //这里可以初始化mem, 它是
    mem = new int[amount + 1];
    Arrays.fill(mem,-666);
    return dp(coins, amount);
  }

  private int dp(int[] coins, int amount) {


     //边界条件优先，然后才是备忘录
    int res=Integer.MAX_VALUE;
    if(amount==0) return 0;
    if(amount<0) return -1;

    if (mem[amount] != -666) {
      return mem[amount];
    }

    
    for(int coin: coins){
      int subProblem = dp(coins, amount - coin);
      if(subProblem ==-1) continue;   //当前子问题无解，跳到下一个子问题
      res= Math.min(res, subProblem +1);

    }
    int result = res == Integer.MAX_VALUE ? -1 : res;
    mem[amount] = result;
    return result;

  }
}
```



### 自底向上递推解法

递推解法也是消除重叠子问题的办法。dp数组：参数是索引，值是解

**`dp` 数组的定义：当目标金额为 `i` 时，至少需要 `dp[i]` 枚硬币凑出**。

```java
int coinChange(int[] coins, int amount) {
    int[] dp = new int[amount + 1];
    // 数组大小为 amount + 1，初始值也为 amount + 1
    Arrays.fill(dp, amount + 1);

    // base case
    dp[0] = 0;
    // 外层 for 循环在遍历所有状态的所有取值
    for (int i = 0; i < dp.length; i++) {
        // 内层 for 循环在求所有选择的最小值
        for (int coin : coins) {
            // 子问题无解，跳过
            if (i - coin < 0) {//减去一块硬币后，总金额为负数了
                continue;
            }
            dp[i] = Math.min(dp[i], 1 + dp[i - coin]);
        }
    }
    return (dp[amount] == amount + 1) ? -1 : dp[amount];
}

```

> PS：为啥 `dp` 数组中的值都初始化为 `amount + 1` 呢，因为凑成 `amount` 金额的硬币数最多只可能等于 `amount`（全用 1 元面值的硬币），所以初始化为 `amount + 1` 就相当于初始化为正无穷，便于后续取最小值。为啥不直接初始化为 int 型的最大值 `Integer.MAX_VALUE` 呢？因为后面有 `dp[i - coin] + 1`，这就会导致整型溢出。