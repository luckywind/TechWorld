[力扣](https://leetcode-cn.com/problems/longest-increasing-subsequence/)


给你一个整数数组 `nums` ，找到其中最长严格递增子序列的长度。

子序列是由数组派生而来的序列，删除（或不删除）数组中的元素而不改变其余元素的顺序。例如，`[3,6,2,7]` 是数组 `[0,3,1,6,2,2,7]` 的子序列。

 

**示例 1：**

```
输入：nums = [10,9,2,5,3,7,101,18]
输出：4
解释：最长递增子序列是 [2,3,7,101]，因此长度为 4 。
```

# 思路

采用动态规划，自底向上：

边界条件，最优子结构，状态转换方程，重叠子问题

假设长度为n的序列最长子序列长度为f(n)，则：

边界条件：f(1)=1

最优子结构：f(n)只与f(n-1)有关系

状态转换：

1. 穷举分析：

**数组num[i]的最长递增子序列长度时**，可以思考下**相关子问题**，比如原问题是否跟**子问题**num[i-1]的最长递增子序列长度有关呢？我们可以**发现一个规律**：

如果新加入一个元素nums[i], 最长递增子序列要么**是以nums[i]结尾的递增子序列**，要么就是**nums[i-1]的最长递增子序列**。看到这个，是不是很开心，nums[i]的最长递增子序列(**原问题**)已经跟**子问题** nums[i-1]的最长递增子序列有关联了。

```
原问题数组nums[i]的最长递增子序列 = 子问题数组nums[i-1]的最长递增子序列/nums[i]结尾的最长递增子序列
```

但是**如何把nums[i]结尾的递增子序列(原问题状态)也转化为对应的子问题**呢？要是nums[i]结尾的递增子序列也跟nums[i-1]的最长递增子序列(**子问题**)有关就好了。又或者nums[i]结尾的最长递增子序列，跟前面子问题num[j]（0=<j<i）结尾的最长递增子序列(**子问题状态**)有关就好了。

nums[i]的最长递增子序列，不就是**从以数组num[i]每个元素结尾的最长子序列集合，取元素最多（也就是长度最长）那个嘛**，所以原问题，我们转化成求出以数组nums每个元素结尾的最长子序列集合，再取**最大值**。想到这，我们就可以**用dp[i]表示以num[i]这个数结尾的最长递增子序列的长度**

其实，**nums[i]结尾的自增子序列，只要找到比nums[i]小的子序列，加上nums[i]** 就可以啦。显然，可能形成多种新的子序列，我们选最长那个，就是dp[i]的值啦

我们发现有这样的规律：

一个以nums[i]结尾的数组nums

如果存在j属于区间[0，i-1],并且num[i]>num[j]的话，则有
dp(i) =max(dp(j))+1

2. 最简单的边界情况

当nums数组只有一个元素时，最长递增子序列的长度dp(1)=1,当nums数组有两个元素时，dp(2) =2或者1， 因此边界就是dp(1)=1。

3. 最优结构

   ```
   dp(i) =max(dp(j))+1，存在j属于区间[0，i-1],并且num[i]>num[j]。
   dp(i) = 1 , 不存在j属于区间[0，i-1],并且num[i]>num[j]。
   ```
   
   
   
   
   
   所以数组num[i]的最长递增子序列就是：
   
   ```
   最长递增子序列 =max(dp[i])
   ```
   
   

# 代码

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        if (nums.length == 0) {
            return 0;
        }
        int[] dp = new int[nums.length];
        //初始化就是边界情况
        dp[0] = 1;
        int maxans = 1;
        //自底向上遍历
        for (int i = 1; i < nums.length; i++) {
            dp[i] = 1;
            //从下标0到i遍历
            for (int j = 0; j < i; j++) {
                //找到前面比nums[i]小的数nums[j],即有dp[i]= dp[j]+1
                if (nums[j] < nums[i]) {
                    //因为会有多个小于nums[i]的数，也就是会存在多种组合了嘛，我们就取最大放到dp[i]
                   
									/**
									注意，这里两步合成了一步： 
									1. dp[i] = dp[j] + 1;
									2. dp[i] = Math.max(dp[i], dp[i-1]);
									*/
                    dp[i] = Math.max(dp[i], dp[j] + 1);
                }
            }
            //求出dp[i]后，dp最大那个就是nums的最长递增子序列啦
            maxans = Math.max(maxans, dp[i]);
        }
        return maxans;
    }
}
```

# 另外一种讲解

方法：动态规划（这是使用动态规划解决的一个经典问题）

明确题目中的条件：

- 子序列：不要求连续子序列，只要保证元素前后顺序一致即可；
- 上升：这里的「上升」是「严格上升」，例如： `[2, 3, 3, 6, 7]` 这样的子序列是不符合要求的。

**题目只问最长上升子序列的长度，没有问最长上升子序列是什么，因此考虑使用动态规划**。

> 动态规划，不考虑具体题解？

第 1 步：状态定义。`dp[i]` 表示以 `nums[i]` 结尾的最长上升子序列的长度。即：在 `[0, ..., i]` 的范围内，选择以数字 `nums[i]` 结尾可以获得的最长上升子序列的长度。

>  说明：以 `nums[i]` 结尾，是子序列动态规划问题的经典设计状态思路，思想是**动态规划的无后效性（定义得越具体，状态转移方程越好推导）**。

第 2 步：推导状态转移方程：遍历到 `nums[i]` 的时候，我们应该把下标区间 `[0, ... ,i - 1]` 的 `dp` 值都看一遍，如果当前的数 `nums[i]` 大于之前的某个数，那么 `nums[i]` 就可以接在这个数后面形成一个更长的上升子序列。把前面的数都看了， `dp[i]` 就是它们的最大值加 $1$​。**即比当前数要小的那些里头，找最大的，然后加 $1$​ 。**

状态转移方程即：`dp[i] = max(1 + dp[j] if j < i and nums[j] < nums[i])`。

第 3 步：初始化。单独一个数是子序列，初始化的值为 1；

第 4 步：输出。应该扫描这个 `dp` 数组，其中最大值的就是题目要求的最长上升子序列的长度。

Java 代码：

```java
class Solution {
    public int lengthOfLIS(int[] nums) {
        int len = nums.length;
        if (len < 2) {
            return len;
        }
        int[] dp = new int[len];
        Arrays.fill(dp, 1);
        
        int res = dp[0];
        for (int i = 1; i < len; i++) {
            // 看以前的，比它小的，说明可以接在后面形成一个更长的子序列
            // int curMax = Integer.MIN_VALUE; 不能这样写，万一前面没有比自己小的，
            // 这个值就得不到更新
            for (int j = 0; j < i; j++) {
                if (nums[j] < nums[i]) {
                    dp[i] = Math.max(dp[j] + 1, dp[i]);
                }
            }
            
            // 在遍历的时候同时找 dp 数组的最大值
            res = Math.max(res, dp[i]);
        }
        return res;
    }
}
```

时间复杂度：O(N^2)，这里 N 是输入数组的长度； 空间复杂度：O(N)。

补充说明：这道题还有一个经典的，时间复杂度为 O(N \log N) 的解法，它也是动态规划的解法，可以在题解区找到这个方法的解释和代码。

