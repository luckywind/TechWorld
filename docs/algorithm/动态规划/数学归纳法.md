[数学归纳法：循环与递归的钥匙](https://time.geekbang.org/column/article/197058?utm_source=related_read&utm_medium=article&utm_term=related_read)

递归：是一种编程技巧，而不是算法啊！

![img](https://gitee.com/luckywind/PigGo/raw/master/image/65c32d9a5d416d8e8c65783ae59d4a9b.jpg)

>  从现实问题到可计算任务,算法是将数学问题，转换到计算机中的计算任务的桥梁

计算机的核心是算法，算法的核心是数学。

数学归纳法三步骤：

![img](https://gitee.com/luckywind/PigGo/raw/master/image/d6624009d55447e273fc58a8799afbc3.jpg)

进入循环之前的程序中关键变量的值，就是上面所说的第一步中的 k0；而每一次的循环，其实就是第二步中所要证明的那个上一个状态到下一个状态的过程。如果这两者都正确，我们就能很确信地知道，我们的整个循环过程就是正确的。



# 理解递归函数

下面我来举个例子：假如今年我上小学 5 年级，我现在想知道 1～5 年级的年级主任名字，但我现在只知道 5 年级的年级主任的名字，我可能会问一个 4 年级的学弟，希望他能告诉我 1～4 年级主任的姓名。我这个学弟呢，也只知道他们年级主任的名字，那么我这个学弟就会问 3 年级学弟，问他 3 年级及以下的年级主任都有谁，依次类推，最后到了 1 年级的小学弟。1 年级的小学弟，就会告诉 2 年级的学长自己年级主任的名字，2 年级的学长拿到 1 年级的年级主任的名字以后，会把 2 年级年级主任的名字填上去，然后再交给 3 年级的他学长……这样最终到我手里的就会是 1～4 年级的年级主任的所有名字，再加上我自己知道的 5 年级的年级主任姓名，这样，我就知道了全部信息。整个过程，如下图所示：

![img](https://gitee.com/luckywind/PigGo/raw/master/image/713f6589e7b8eb51c8af82ddc1efa65a.jpg)

在这个过程中，每个人问学弟的过程，就是我们所谓的“递”，而拿到学弟给的结果名单以后，再加上自己知道的结果反馈给自己学长的这个过程，就是“归”，整个过程就是我们所谓的“递归”。“递归”的过程，每一步的过程类似，可是问题规模不同。

代码：

```c

#include <stdio.h>

int f(int n) {
    if (n == 1) return 1;
    return f(n - 1) * n;
}

int main() {
    int n;
    scanf("%d", &n);
    printf("%d\n", f(n));
    return 0;
}
```

这段代码中，f 函数的作用，是计算 n 的阶乘的值，也就是从 1 乘到 n 的结果。在 f 函数内部，首先是一个边界条件，就是当 n == 1 的时候，直接返回 1 的阶乘的结果。否则，n 的阶乘的结果，应该等于 n - 1 阶乘的结果再乘上 n ，就得到了 n 的阶乘。在得到 n - 1 阶乘结果的过程中，我们调用的不是别的函数，还是 f 函数本身，只不过传入的参数范围，是一个比 n 更小的范围 n - 1。

关于这个 f 函数，类比于上面年级主任的那个例子，f(n) 就是我整理的信息，f(n - 1) 就是比我要小 1 个年级的学弟所整理得到的信息，而 n == 1 的边界条件判断，就是我那个最小的 1 年级的学弟。最后 f(n - 1) * n 当中的 * n 这个过程，就相当于每个人拿到了学弟整理的信息以后，再加上自己知道的信息，最后递交给自己的学长。

为什么这么做，能保证每个人所得到的信息都是正确的呢？在证明这个过程的时候，我们就需要用到前面提到的数学归纳法了。首先，我们知道 1 年级的学弟肯定能给出正确的信息，这就是数学归纳法中的边界条件。然后我们假设，如果上一个学弟，给出的信息是正确的，那么我所整理出来的信息，就一定是正确的，这就是数学归纳法中的证明过程的正确性。最终，我们就可以得到结论，在这个过程中，所有人获得的信息都是正确的，包括我自己。其实，到了这里，我们也就得到了递归程序设计中的重要的两部分：**边界条件和处理过程。**

- 所谓边界条件，就是当递归函数中的参数等于多少的时候，可以直接返回的条件。
- 处理过程呢，就是设计程序过程，处理递归调用的返回结果，根据递归调用的返回结果，得到本函数的结果。这两部分，分别对应了数学归纳法中的两步，step1 和 step2。当这两步都可以保证正确，所涉及的递归函数程序，也绝对是正确的。

# 实验

打印斐波那契数列,第n项

![img](https://gitee.com/luckywind/PigGo/raw/master/image/faa57fedb330f6c3fa27c22aac2f739a.jpg)

这里分别用递归和循环写了：

```java
public class Fib {

  static int fib(int n) {
    if (n == 1 || n == 2) { //边界条件
      return 1;
    }
    /**
     * 假设上一个状态我们算出来了，
     * 下一个状态是什么？
     */
    return fib(n - 1) + fib(n - 2); //上一个状态到下一个状态的转换
  }

  public static void main(String[] args) {
//    System.out.println(fib(3));
    System.out.println(loopFib(4));
  }

  static int loopFib(int n) {
    if (n == 1 || n == 2) {
      return 1;
    }
    int n1=1, n2=1,tmp;  //n1是n-2,n2是n-1
    for (int i = 2; i < n; i++) {
      tmp = n1; //先把n1存起来，再更新它俩
      n1 = n2;
      n2 = tmp + n2;
      System.out.println("n1:"+n1+",n2:"+n2);
    }
    return n2;
  }
}
```

## 不定层循环

完成一个可变循环层数的程序。我们可以一开始假设，有一个函数，是实现 5 层循环打印的程序，那么它会循环 n 次，每次调用一个实现 4 层循环打印的程序。依照这个大体的思路，我们就可以写出如下代码框架：

```c

int print_loop(int k, int n) {
    if (k == 0) {
        // 打印一行
    }
    for (int i = 1; i <= n; i++) {
        print_loop(k - 1, n);
    }
    return;
}
```

要打印的这行内容，与每层循环遍历到的数字有关系，那么我们就需要记录每层循环遍历到的数字。

