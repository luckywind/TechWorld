# 窗口函数

```sql
SUM(sale_price) over(order by product_id rows 1 preceding) 
自身+上1条记录
SUM(sale_price) over(order by product_id rows 1 following) 
自身+下1条记录
SUM(sale_price) over(order by product_id rows between 1 preceding and 2 following) 
自身+上1条记录+下2条记录
sum(cost) over() as sample1,--所有行相加
sum(cost) over(partition by name) as sample2,--按name 分组，组内数据相加
sum(cost) over(partition by name order by orderdate) as sample3,--按name分组并按orderdate排序（这里注意，一次累加的是下一个orderdate的所有数据），组内数据累加
sum(cost) over(partition by name order by orderdate rows between unbounded preceding  and current row) as sample4, --和sample3一样，由起点到当前行的聚合
sum(cost) over(partition by name order by orderdate rows between 1 preceding and current row) as sample5,--当前行和前面一行做聚合
sum(cost) over(partition by name order by orderdate rows between 1 preceding and 1 following )as sample6,--当前行和前一行及后面一行
sum(cost) over(partition by name order by orderdate rows between current row and unbounded following) as sample7 --当前行及后面所有行
from order1;
```









# 分析函数

[参考](http://lxw1234.com/archives/tag/hive-window-functions)

id,name,company_name,job_name, entry_time,leave_time

```sql
insert overwrite table tmp.asume
values 
(1, '张三', '华为','数据研发',20171011,20181001) ,
(1, '张三', '华为','数据研发',20181011,20191030) ,
(1, '张三', '华为','后台研发',20191031,20201101) ,
(1, '张三', '阿里','数据研发',20201105,20211003) ,
(1, '张三', '华为','后台研发',20211004,20211127),
(2, '李四', '华为','数据研发',20181011,20191029) ,
(2, '李四', 'oppo','数据研发',20191101,null) 
;
```



## lag

LAG(col,n,DEFAULT) 用于统计窗口内往上第n行值
参数1为列名，参数2为往上第n行（可选，默认为1），参数3为默认值（当往上第n行为NULL时候，取默认值，如不指定，则为NULL）



## lead

与LAG相反
LEAD(col,n,DEFAULT) 用于统计窗口内往下第n行值
参数1为列名，参数2为往下第n行（可选，默认为1），参数3为默认值（当往下第n行为NULL时候，取默认值，如不指定，则为NULL）

### 网页停留时长

[参考](https://blog.csdn.net/kent7306/article/details/50441967)

## first_value

取分组内排序后，截止到当前行，第一个值

## Last_value

取分组内排序后，截止到当前行，最后一个值

## grouping sets

在一个GROUP BY查询中，根据不同的维度组合进行聚合，等价于将不同维度的GROUP BY结果集进行UNION ALL

```sql
SELECT 
month,
day,
COUNT(DISTINCT cookieid) AS uv,
GROUPING__ID 
FROM lxw1234 
GROUP BY month,day 
GROUPING SETS (month,day) 
ORDER BY GROUPING__ID;
```

## cube

根据GROUP BY的维度的所有组合进行聚合。

## rollup

是CUBE的子集，以最左侧的维度为主，从该维度进行层级聚合。



# 案例

## 案例1

### lag

找到每个员工的当前公司与上一段经历的公司

```sql
select id, name,company_name,
lag(company_name)over(partition by id order by entry_time) last_company_name
from tmp.asume;
| id  | name  | company_name  | last_company_name  |
+-----+-------+---------------+--------------------+--+
| 1   | 张三    | 华为            | NULL               |
| 1   | 张三    | 华为            | 华为                 |
| 1   | 张三    | 华为            | 华为                 |
| 1   | 张三    | 阿里            | 华为                 |
| 1   | 张三    | 华为            | 阿里                 |
| 2   | 李四    | 华为            | NULL               |
| 2   | 李四    | oppo          | 华为                 |
+-----+-------+---------------+--------------------+--+
```

找到每个员工当前公司与上家公司

```sql
select id, name,company_name,last_company_name from 
(
  select id, name,company_name,
lag(company_name)over(partition by id,company_name order by entry_time) last_company_name
from tmp.asume
)
group by id, name,company_name,last_company_name
;
| id  | name  | company_name  | last_company_name  |
+-----+-------+---------------+--------------------+--+
| 2   | 李四    | 华为            | NULL               |
| 2   | 李四    | oppo          | NULL               |
| 1   | 张三    | 华为            | NULL               |
| 1   | 张三    | 华为            | 华为                 |
| 1   | 张三    | 阿里            | NULL               |
+-----+-------+---------------+--------------------+--+
```

### first_value

```sql
select id, name,company_name,
row_number()over(partition by id order by entry_time) rn,
first_value(company_name)over(partition by id order by entry_time) first_value
from tmp.asume;
```

