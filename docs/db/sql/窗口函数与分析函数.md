# 窗口函数

[s](https://spark.apache.org/docs/latest/sql-ref-syntax-qry-select-window.html)

语法

```sql
窗口函数 [ nulls_option ] OVER
( [  { PARTITION | DISTRIBUTE } BY partition_col_name = partition_col_val ( [ , ... ] ) ]  -- 分组
  { ORDER | SORT } BY expression [ ASC | DESC ] [ NULLS { FIRST | LAST } ] [ , ... ]       -- 排序
  [ window_frame ] )   -- 窗口表达式
```



**1. 窗口函数**

- 秩函数

  **Syntax:** `RANK | DENSE_RANK | PERCENT_RANK | NTILE | ROW_NUMBER`

- 分析函数

  **Syntax:** `CUME_DIST | LAG | LEAD | NTH_VALUE | FIRST_VALUE | LAST_VALUE`

- 聚合函数

  **Syntax:** `MAX | MIN | COUNT | SUM | AVG | ...`

2. **nulls_option 是否跳过null值**

   - RESPECT NULLS 不跳过(默认)

   - IGNORE NULLS   

     > 只有LAG | LEAD | NTH_VALUE | FIRST_VALUE | LAST_VALUE可以使用

3. **窗口表达式**
   { RANGE | ROWS } { frame_start | BETWEEN frame_start AND frame_end }

   > 指定窗口开始，默认当前行结束
   >
   > 也可以用between指定开始和结束

​    窗口起止表达式

UNBOUNDED PRECEDING | offset PRECEDING | CURRENT ROW | offset FOLLOWING | UNBOUNDED FOLLOWING

> 开始和结束如何

frame_end默认是当前行



## 数据

```sql
with orders as (
  select stack(
  12,
  'jack','2017-01-01',10,
  'tony','2017-01-01',15,
  'jack','2017-01-02',23,
  'tony','2017-01-04',29,
  'jack','2017-01-07',46,
  'jack','2017-01-08',42,
  'tony','2017-02-03',50,
  'jack','2017-04-06',55,
  'mart','2017-04-08',62,
  'mart','2017-04-09',68,
  'neil','2017-04-11',12,
  'mart','2017-05-10',75
  )as (name,orderdate,cost)
)

select * from orders;
```



```sql
with orders as (
  select stack(
  12,
  'jack','2017-01-01',10,
  'tony','2017-01-01',15,
  'jack','2017-01-02',23,
  'tony','2017-01-04',29,
  'jack','2017-01-07',46,
  'jack','2017-01-08',42,
  'tony','2017-02-03',50,
  'jack','2017-04-06',55,
  'mart','2017-04-08',62,
  'mart','2017-04-09',68,
  'neil','2017-04-11',12,
  'mart','2017-05-10',75
  )as (name,orderdate,cost)
)
select *, sum(cost) over(order by orderdate ROWS 1 PRECEDING) as `和前一项累计`
from orders;
```



| name | orderdate  | cost | `和前一项累计` |      |
| ---- | ---------- | ---- | -------------- | ---- |
| jack | 2017-01-01 | 10   | 10             |      |
| tony | 2017-01-01 | 15   | 25             |      |
| jack | 2017-01-02 | 23   | 38             |      |
| tony | 2017-01-04 | 29   | 52             |      |
| jack | 2017-01-07 | 46   | 75             |      |
| jack | 2017-01-08 | 42   | 88             |      |
| tony | 2017-02-03 | 50   | 92             |      |
| jack | 2017-04-06 | 55   | 105            |      |
| mart | 2017-04-08 | 62   | 117            |      |
| mart | 2017-04-09 | 68   | 130            |      |
| neil | 2017-04-11 | 12   | 80             |      |
| mart | 2017-05-10 | 75   | 87             |      |

## 向前的窗口

```sql
with orders as (
  select stack(
  12,
  'jack','2017-01-01',10,
  'tony','2017-01-01',15,
  'jack','2017-01-02',23,
  'tony','2017-01-04',29,
  'jack','2017-01-07',46,
  'jack','2017-01-08',42,
  'tony','2017-02-03',50,
  'jack','2017-04-06',55,
  'mart','2017-04-08',62,
  'mart','2017-04-09',68,
  'neil','2017-04-11',12,
  'mart','2017-05-10',75
  )as (name,orderdate,cost)
)
select *, sum(cost) over(order by orderdate ROWS 1 PRECEDING) as `和前一项累计`
from orders;
```

## 向后的窗口

```sql
with orders as (
  select stack(
  12,
  'jack','2017-01-01',10,
  'tony','2017-01-01',15,
  'jack','2017-01-02',23,
  'tony','2017-01-04',29,
  'jack','2017-01-07',46,
  'jack','2017-01-08',42,
  'tony','2017-02-03',50,
  'jack','2017-04-06',55,
  'mart','2017-04-08',62,
  'mart','2017-04-09',68,
  'neil','2017-04-11',12,
  'mart','2017-05-10',75
  )as (name,orderdate,cost)
)
select *, sum(cost) over(order by orderdate ROWS between current row and   1 FOLLOWING) as `向后一行聚合`
from orders;
```

| name | orderdate  | cost | 向后一行聚合 |      |
| ---- | ---------- | ---- | ------------ | ---- |
| jack | 2017-01-01 | 10   | 25           |      |
| tony | 2017-01-01 | 15   | 38           |      |
| jack | 2017-01-02 | 23   | 52           |      |
| tony | 2017-01-04 | 29   | 75           |      |
| jack | 2017-01-07 | 46   | 88           |      |
| jack | 2017-01-08 | 42   | 92           |      |
| tony | 2017-02-03 | 50   | 105          |      |
| jack | 2017-04-06 | 55   | 117          |      |
| mart | 2017-04-08 | 62   | 130          |      |
| mart | 2017-04-09 | 68   | 80           |      |
| neil | 2017-04-11 | 12   | 87           |      |
| mart | 2017-05-10 | 75   | 75           |      |





```sql
select sum(cost) over(order by orderdate ROWS 1 PRECEDING) from orders;
自身+上1条记录
SUM(sale_price) over(order by product_id rows 1 following) 
自身+下1条记录
SUM(sale_price) over(order by product_id rows between 1 preceding and 2 following) 
自身+上1条记录+下2条记录
sum(cost) over() as sample1,--所有行相加
sum(cost) over(partition by name) as sample2,--按name 分组，组内数据相加
sum(cost) over(partition by name order by orderdate) as sample3,--按name分组并按orderdate排序（这里注意，一次累加的是下一个orderdate的所有数据），组内数据累加
sum(cost) over(partition by name order by orderdate rows between unbounded preceding  and current row) as sample4, --和sample3一样，由起点到当前行的聚合
sum(cost) over(partition by name order by orderdate rows between 1 preceding and current row) as sample5,--当前行和前面一行做聚合
sum(cost) over(partition by name order by orderdate rows between 1 preceding and 1 following )as sample6,--当前行和前一行及后面一行
sum(cost) over(partition by name order by orderdate rows between current row and unbounded following) as sample7 --当前行及后面所有行
from order1;
```





# 分析函数



[参考](http://lxw1234.com/archives/tag/hive-window-functions)

id,name,company_name,job_name, entry_time,leave_time

```sql
insert overwrite table tmp.asume
values 
(1, '张三', '华为','数据研发',20171011,20181001) ,
(1, '张三', '华为','数据研发',20181011,20191030) ,
(1, '张三', '华为','后台研发',20191031,20201101) ,
(1, '张三', '阿里','数据研发',20201105,20211003) ,
(1, '张三', '华为','后台研发',20211004,20211127),
(2, '李四', '华为','数据研发',20181011,20191029) ,
(2, '李四', 'oppo','数据研发',20191101,null) 
;
```



## lag

LAG(col,n,DEFAULT) 用于统计窗口内往上第n行值
参数1为列名，参数2为往上第n行（可选，默认为1），参数3为默认值（当往上第n行为NULL时候，取默认值，如不指定，则为NULL）

```sql
with orders as (
  select stack(
  12,
  'jack','2017-01-01',10,
  'tony','2017-01-01',15,
  'jack','2017-01-02',23,
  'tony','2017-01-04',29,
  'jack','2017-01-07',46,
  'jack','2017-01-08',42,
  'tony','2017-02-03',50,
  'jack','2017-04-06',55,
  'mart','2017-04-08',62,
  'mart','2017-04-09',68,
  'neil','2017-04-11',12,
  'mart','2017-05-10',75
  )as (name,orderdate,cost)
)
select *, lag(cost)  over(PARTITION by name order  by orderdate ) as `lagcost`,
lead(cost)  over(PARTITION by name order by  orderdate ) as lead_cost
from orders;
```



| name | orderdate  | cost | lagcost | lead_cost |      |
| ---- | ---------- | ---- | ------- | --------- | ---- |
| mart | 2017-04-08 | 62   |         | 68        |      |
| mart | 2017-04-09 | 68   | 62      | 75        |      |
| mart | 2017-05-10 | 75   | 68      |           |      |
| jack | 2017-01-01 | 10   |         | 23        |      |
| jack | 2017-01-02 | 23   | 10      | 46        |      |
| jack | 2017-01-07 | 46   | 23      | 42        |      |
| jack | 2017-01-08 | 42   | 46      | 55        |      |
| jack | 2017-04-06 | 55   | 42      |           |      |
| tony | 2017-01-01 | 15   |         | 29        |      |
| tony | 2017-01-04 | 29   | 15      | 50        |      |
| tony | 2017-02-03 | 50   | 29      |           |      |
| neil | 2017-04-11 | 12   |         |           |      |

## lead

与LAG相反
LEAD(col,n,DEFAULT) 用于统计窗口内往下第n行值
参数1为列名，参数2为往下第n行（可选，默认为1），参数3为默认值（当往下第n行为NULL时候，取默认值，如不指定，则为NULL）

### 网页停留时长

[参考](https://blog.csdn.net/kent7306/article/details/50441967)

用户Peter在浏览网页，在某个时刻，Peter点进了某个页面，过一段时间后，Peter又进入了另外一个页面，如此反复，那怎么去统计Peter在某个特定网页的停留时间呢，又或是怎么统计某个网页用户停留的总时间呢？

```sql
with user_log as (
  select stack(
  10,
"Peter","2015-10-12 01:10:00","url1",
"Peter","2015-10-12 01:15:10","url2",
"Peter","2015-10-12 01:16:40","url3",
"Peter","2015-10-12 02:13:00","url4",
"Peter","2015-10-12 03:14:30","url5",
"Marry","2015-11-12 01:10:00","url1",
"Marry","2015-11-12 01:15:10","url2",
"Marry","2015-11-12 01:16:40","url3",
"Marry","2015-11-12 02:13:00","url4",
"Marry","2015-11-12 03:14:30","url5"
  )as (userid,time,url)
)
select * from user_log;
```

分析步骤:

1. 获取用户在某个页面停留的起始与结束时间

   > 这里按时间排序后，下一个url的time就是当前url的离开时间，用到lead()函数

2. 结束-开始，得到停留时长

3. 计算用户在每个页面的总停留时长

```sql
with user_log as (
  select stack(
  10,
"Peter","2015-10-12 01:10:00","url1",
"Peter","2015-10-12 01:15:10","url2",
"Peter","2015-10-12 01:16:40","url3",
"Peter","2015-10-12 02:13:00","url4",
"Peter","2015-10-12 03:14:30","url5",
"Marry","2015-11-12 01:10:00","url1",
"Marry","2015-11-12 01:15:10","url2",
"Marry","2015-11-12 01:16:40","url3",
"Marry","2015-11-12 02:13:00","url4",
"Marry","2015-11-12 03:14:30","url5"
  )as (userid,time,url)
),

a as (
select userid,url, time as stime, -- 开始时间
  lead(time) over(partition by userid order by time) as etime,-- 离开时间
  UNIX_TIMESTAMP(lead(time) over(partition by userid order by time),'yyyy-MM-dd HH:mm:ss')- UNIX_TIMESTAMP(time,'yyyy-MM-dd HH:mm:ss') period  -- 停留时长
  from user_log
)
select userid,url, sum(period) `总停留时长` from a  
group by userid , url 
order by userid;
```



| userid | url  | 总停留时长 |      |
| ------ | ---- | ---------- | ---- |
| Marry  | url1 | 310        |      |
| Marry  | url2 | 90         |      |
| Marry  | url3 | 3380       |      |
| Marry  | url4 | 3690       |      |
| Marry  | url5 |            |      |
| Peter  | url1 | 310        |      |
| Peter  | url2 | 90         |      |
| Peter  | url3 | 3380       |      |
| Peter  | url4 | 3690       |      |
| Peter  | url5 |            |      |







## first_value

取分组内排序后，截止到当前行，第一个值

```sql
first_value(cost)  over(PARTITION by name  ) as fist,
last_value(cost)  over(PARTITION by name  ) as last
```



## Last_value

取分组内排序后，截止到当前行，最后一个值

## grouping sets

在一个GROUP BY查询中，根据不同的维度组合进行聚合，等价于将不同维度的GROUP BY结果集进行UNION ALL

```sql
SELECT 
month,
day,
COUNT(DISTINCT cookieid) AS uv,
GROUPING__ID 
FROM lxw1234 
GROUP BY month,day 
GROUPING SETS (month,day) 
ORDER BY GROUPING__ID;
```

## cube

根据GROUP BY的维度的所有组合进行聚合。

## rollup

是CUBE的子集，以最左侧的维度为主，从该维度进行层级聚合。



# 案例

## 案例1

### lag

找到每个员工的当前公司与上一段经历的公司

```sql
select id, name,company_name,
lag(company_name)over(partition by id order by entry_time) last_company_name
from tmp.asume;
| id  | name  | company_name  | last_company_name  |
+-----+-------+---------------+--------------------+--+
| 1   | 张三    | 华为            | NULL               |
| 1   | 张三    | 华为            | 华为                 |
| 1   | 张三    | 华为            | 华为                 |
| 1   | 张三    | 阿里            | 华为                 |
| 1   | 张三    | 华为            | 阿里                 |
| 2   | 李四    | 华为            | NULL               |
| 2   | 李四    | oppo          | 华为                 |
+-----+-------+---------------+--------------------+--+
```

找到每个员工当前公司与上家公司

```sql
select id, name,company_name,last_company_name from 
(
  select id, name,company_name,
lag(company_name)over(partition by id,company_name order by entry_time) last_company_name
from tmp.asume
)
group by id, name,company_name,last_company_name
;
| id  | name  | company_name  | last_company_name  |
+-----+-------+---------------+--------------------+--+
| 2   | 李四    | 华为            | NULL               |
| 2   | 李四    | oppo          | NULL               |
| 1   | 张三    | 华为            | NULL               |
| 1   | 张三    | 华为            | 华为                 |
| 1   | 张三    | 阿里            | NULL               |
+-----+-------+---------------+--------------------+--+
```

### first_value

```sql
select id, name,company_name,
row_number()over(partition by id order by entry_time) rn,
first_value(company_name)over(partition by id order by entry_time) first_value
from tmp.asume;
```

