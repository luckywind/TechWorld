# Java基本类型

[参考](https://blog.csdn.net/LagerSwan/article/details/104034723)

分别为 boolean、byte、short、char、int、long、float、double，这八种基本数据类型通常分为四大类型;

逻辑类型（布尔类型）：boolean；
整数类型 ：byte、short、int、long；
浮点类型 ：float、double；
字符类型 ：char；



**1、 整数数据类型**

- byte：1个字节，8位，256种状态，取值范围为【-128,127】
- short：2个字节，16位，65536种状态，取值范围为【-32768,32767】
- int：4个字节，32位，整数类型默认是int类型，取值范围约21亿（10个数字）
  -2147483648～2147483647 (10个数字，表示decimal时只能精确表示9位有效数字)
- long：8个字节，64位，long类型表示long类型常量，要加L或者l，建议加L
  -9223372036854775808到9223372036854775807（19个数字，表示decimal时只能精确表示18位有效数字）

**2、 小数数据类型**

- float：4个字节，32位，单精度，能精确到6~7位($$2^{23}=8388608（7位数）$$)，声明一个小数类型，要加F或者f，建议加F

认保留8位有效数字，有效数字是从常量的第一数字开始算起

当存在0开头的赋值时，则从与数字相邻的第一个0开始算起，一共取8位；

如：float test4 = 0.0123456789 ; //则系统存储0.01234567 ；float test4 = 0.00123456789 ; //则系统存储0.001234567 ；

- double：8个字节，64位，双精度，能精确到15~16位($$2^{52}=4503599627370496(16位数)$$)，小数类型默认是double类型
  默认保留16位有效数字，有效数字是从常量的第一数字开始算起

**3、 字符数据类型**

char：2个字节，16位，0~65535 ; char是没有负数的；字符表示Unicode（万国码）编码表中的每一个符号，每个符号使用单引号引起来，其中前128个符号和ASCII表相同

**4、 布尔数据类型**

boolean：占1位，有true和false2个值，一个表示真，一个表示假，一般用于表示逻辑运算

## Java浮点数

[参考Java浮点数](https://blog.csdn.net/a327369238/article/details/52354811)

### float

一个float4字节32位，分为三部分：符号位，指数位，尾数位。

| 符号位（S）：1bit | 指数位（E）：8bit | 尾数位（M）：23bit |
| ----------------- | ----------------- | ------------------ |
|                   |                   |                    |

(1).**符号位**(S)：最高位（31位）为符号位，表示整个浮点数的正负，0为正，1为负；

(2).**指数位**(E)：23-30位共8位为指数位，这里指数的底数规定为2（取值范围：0-255）。这一部分的最终结果格式为：$$2^{E − 127}$$
 ，即范围-127~128。另外，标准中，还规定了，当指数位8位全0或全1的时候，浮点数为非正规形式（这个时候尾数不一样了），所以指数位真正范围为：-126~127。

(3).**尾数位**(M)：0-22位共23位为尾数位，表示小数部分的尾数，即形式为1.M或0.M，至于什么时候是1，什么时候是0，则由指数和尾数共同决定（注意了，这个小数部分最高位并不在这32位里面，只是个隐含信息，由指数部分和尾数部分共同决定，说白了就是IEEE754这样规定的）。

当指数位全是0时，此时就不是（1.M）而是（0.M）了，是8个1的时候，如果小数域全是0，表示的是无穷，其余的表示NAN。

1.M,即小数部分最高有效位是1的数被称为正规（规格化）形式。小数部分最高有效位是0的数被称为非正规（非规格化）形式，其他情况是特殊值。
最终float的值 =$$  (-1)^S*(2^{E-127})*(1.M ) $$





#### 精度

[关于Java float和double精度范围大小](https://www.jb51.net/article/231635.htm)

- **指数位决定了大小范围**

- **而小数位决定了计算精度**

  > float只有23位小数位，int的32位都可以当作小数位，所以int表示decimal时，精度更高

可能还不够明白，举例子吧：

- float的小数位只有23位，即二进制的23位，能表示的最大的十进制数为2的23次方，即8388608，即十进制的7位，严格点(有些7位数字表示不了所以不能把所有7位都精确？)，精度只能百分百保证十进制的6位运算。
- double的小数位有52位，对应十进制最大值为4 503 599 627 370 496，这个数有16位，所以计算精度只能百分百保证十进制的15位运算。

 float和double的精度是由尾数的位数来决定的。浮点数在内存中是按科学计数法来存储的，其整数部分始终是一个隐含着的“1”，由于它是不变的，故不能对精度造成影响。
 float：2^23 = 8388608，一共七位，这意味着最多能有7位有效数字，但绝对能保证的为6位，也即float的精度为6~7位有效数字；
 double：2^52 = 4503599627370496，一共16位，同理，double的精度为15~16位。

#### 取值范围

![image-20230419095734461](https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/image-20230419095734461.png)

根据计算公式$$   (-1)^S*(2^{E-127})*(1.M ) $$

指数部分范围是[-126, 127] ，

尾数范围是[1,  1.11...(小数部分23位全是1)] ， 注意，这1.11...的计算方式：

```
1.1 ----> 1+1/2 = 1.5 = 2-1/2
1.11 -----> 1+1/2 +1/4 = 1.75 = 2-1/4
```

所以，最终规格化的浮点数的表示范围是正负$$(2^{127})*(2-2^{-23})=2^{128}-2^{104}=3.40*10^{38}$$

> 为什么float只占4子节，却能表达这么大，因为有指数位，这个数字会迅速增长； [带来的缺陷就是](https://zhuanlan.zhihu.com/p/84453627)
>
> 精度不足，只能精确表示6～7位

 -149的得来：看上面理论应该是150（指数全0，则指数值 = 0 -127，这个时候尾数取最小，$$2^{−23}$$
 ，则-127-23 = -150），可不知道为什么是149，我查到的资料是说，全0，全1为特殊值，不作为范围内的值，上面的float的最大最小值Float.MAX_VALUE都是接近$$2^{128}$$。故值 = $$ (-1)^S*(2^{-126})*(2^{-23})= +/-2 2^{-149}$$



### double

double这里就类似float，只是double的长度更大，所以范围就更大，但规则是一样的。double的值 =$$(-1)^S*(2^{E-1023})*(1.M )$$

double类型是64位，符号位占用1位，指数位占用11位，小数位占用52位。

**范围**

double的范围为-2^1024 ~ +2^1024，也即-1.79E+308 ~ +1.79E+308。

# decimal

[参考](https://www.cnblogs.com/tusheng/articles/9389672.html)

decimal(M,D), 其能表示的范围依赖于M和D的值，例如：decimal(5,2)，则该字段可以存储-999.99~999.99，最大值为999.99。 也就是说D表示的是小数部分长度，(M-D)表示的是整数部分长度。

| 类型       | 大小                                     | 范围（有符号）                                               | 范围（无符号）                                               | 用途            |
| ---------- | ---------------------------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ | --------------- |
| ==float==  | 4 bytes                                  | (-3.402 823 466 E+38，-1.175 494 351 E-38)，0，(1.175 494 351 E-38，3.402 823 466 351 E+38) | 0，(1.175 494 351 E-38，3.402 823 466 E+38)                  | 单精度 浮点数值 |
| ==double== | 8 bytes                                  | (-1.797 693 134 862 315 7 E+308，-2.225073858507 2014E-308)，0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 0，(2.225 073 858 507 201 4 E-308，1.797 693 134 862 315 7 E+308) | 双精度 浮点数值 |
| decimal    | 对decimal(M,D) ，如果M>D，为M+2否则为D+2 | 依赖于M和D的值                                               | 依赖于M和D的值                                               | 小数值          |



## java BigDecimal

数据库类型decimal在java实体类中对应BigDecimal

28个有效位，128bit

不可变，任意精度有符号decimal数。一个BigDecimal由一个unscaled(非标度)值和一个int型的scale(标度)组成。如果scale是0或正数，代表小数点后有几位；如果scale是负数，意味着这个BigDecimal的值是$$unscaledValue × 10^{-scale}$$

BigDecimal用来对超过16位有效位的数进行精确的运算。双精度浮点型变量double可以处理16位有效数

### 构造

```java
BigDecimal BigDecimal(String s);     //推荐使用
static BigDecimal valueOf(double d); //推荐使用
BigDecimal BigDecimal(double d);     //不要使用，因为小数的精度不能保证
```

## BigInteger

不可变任意精度整型，提供类似原生integer类型的所有操作。算术运算的语义完全模仿的Java的整数算术运算符，由于biginteger足够大，所以没有溢出操作。

位操作在其操作数的二进制补码表示的单个位上操作。 如有必要，操作数将进行符号扩展，以使其包含指定的位。 没有任何一位操作可以产生一个与操作BigInteger具有不同符号的BigInteger，因为它们只影响一个位，并且该类提供的任意大抽象确保概念上存在无限多个“虚拟符号位” “在每个BigInteger之前。

### 范围

BigInteger里面使用int数组来存储，存储的最大范围是$$[-2^{214748364732-1}，2^{214748364732-1} -1]$$

```java
final int[] mag;//使用int数组存储

privte BigInteger(long val){
	if(val < 0){
		val = -val;
		signum = -1;
		}
	else{
		signum = 1;
	}
	int highWord = (int)<var >>> 32);  //前4个子节
	if(highWord == 0){
		mag = new int[1];
		mag[0] = (int)val;
	}
	else{
		mag = new int[2];
		mag[0] = highWord;
		mag[1] = (int)val;
	}
}

```

它里面是通过int数组存放的，这些int数组里的int数值本质上也是通过二进制数位来实现的。
而int的最大值为：2147483647。也就是mag[]里面可以放入2147483647个int值，每个int值为32位，
故mag[] 可以表示的数组范围为：$$[-2^{214748364732-1}，2^{214748364732-1} -1]$$,当结果超出支持范围-2 `Integer.MAX_VALUE` （不包括）到+2 `Integer.MAX_VALUE` （不包括）时，BigInteger构造函数和操作抛出 `ArithmeticException` 。

也就是通俗的理解只要计算机的内存足够大，BigInteger类的实例就可以放足够大的数字





```
public byte[] toByteArray()
```

Returns a byte array containing the two's-complement representation of this BigInteger. The byte array will be in *big-endian* byte-order: the most significant byte is in the zeroth element. The array will contain the minimum number of bytes required to represent this BigInteger, including at least one sign bit, which is `(ceil((this.bitLength() + 1)/8))`. (This representation is compatible with the [`(byte[])`](https://docs.oracle.com/javase/7/docs/api/java/math/BigInteger.html#BigInteger(byte[])) constructor.)

- **Returns:**

  a byte array containing the two's-complement representation of this BigInteger.

