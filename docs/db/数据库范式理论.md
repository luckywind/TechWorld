# 准备知识

1. 码=键，主码就是主键

2. 候选码： 可以唯一确定一行数据的属性，可以是联合属性，候选码可以有多个

   例如：

   2.1 学生表中，学号就可以唯一确定一个学生，那么学号就是候选码

   2.2 学生选课表中，学号不能唯一确定一个选课关系，而是由学号和课号共同确定一个选课关系， 所以学号和课号的**组合做候选码**，注意不是分别做候选码。

   2.3 在学生表中加入身份证号属性，学号和身份证号都可以唯一的确定一个学生记录，所以学号和身份证号都是候选键，这时是**分别做候选码**，有两个候选码。
   
3. 主码：主码是人为规定的，从候选码中选一个(**因此主码必须能唯一确定一行数据**)

   例如：在学生表中加入身份证号属性，那么学号和身份证号都是候选码，这时人为的规定学号为主码

4. 主属性：主属性是单个属性，不存在多个，就是一个单独的属性。**包含在候选键中的属性就是主属性**。

  例如：选课关系表中，学号和课号联合起来做主键，当然主键也是候选键，所以学号属性和课号属性都是主属性。

5. 非主属性： 不是主属性的属性都是非主属性

6. **主关系键**：候选键

# 依赖关系

## 完全函数依赖

是关系模式中属性之间的一种逻辑依赖关系。
eg：

- 在学生关系中，Student中学号sno决定了一个学生的姓名sname，就说sno->sname, sno函数决定sname，sname函数依赖于sno。
  函数依赖需要了解部分函数依赖和传递函数依赖

## 部分函数依赖

在关系模式R中，X和Y是R关系的子集，X的真子集X’,有X’->Y,则称Y对X部分函数依赖。
eg：

现在有一个关系模式
          SCD(sno，cno，Score，sname)
          sno：学号 cno：课程号 Score：成绩 sname：姓名
这时分析该关系模式，sno和cno的组合做主键，所有sno和cno的组合决定所有其他属性
          (sno,cno)->Score,sname
但是姓名sname只需要sno就可以决定了
          sno->sname
所以sname部分函数依赖(sno,cno)
**部分函数依赖是多值函数依赖**

## 传递函数依赖

在关系模式R中，X,Y,Z是U的子集，若X->Y,Y-/->X,Y->Z,则有Z对X传递函数依赖
eg：

现在有一个关系模式
          R(sno,sname,dept,depter)
          sno:学号 sname:姓名 dept:院系 depter：院长
分析该关系模式，sno在这里做主键，sno可以决定所有：
          sno->sname , dept , depter
但是院系dept不能决定学生sno，确可以决定院长depter是谁
          dept-/->sno dept->depter
又：sno->depter
所以depter传递函数依赖sno

# 第一范式

第一范式(1NF)：**每一列要保持原子特征 列是基本数据项，不能再进行拆分**，否则设计成一对多的关系。

三个条件：

- 每一行都是唯一的
- 每列不可再分
- 无重复列，没有两个列包含相同数据

不满足第一范式就不能称之为关系型数据库

     学生表（学号、用户名、性别、年龄，地址）
这里的地址我可以输入很多信息
     eg：陕西省西安市未央区xx小区
     陕西省咸阳市xx小区
这样是及其不规范的，而且地址包括很多原子信息
**拆分改造后：**
     学生表（学号、用户名、性别、年龄、地址ID）
     地址表（地址ID、省、市、区）

# 第二范式

第二范式（2NF）：每个非主属性(联合主键外的属性)都完全函数依赖于R的主关系键
**也就是说在第一范式的基础上，消除非主属性对主关系键的部分函数依赖，就可以成为第二范式。**
注意：**部分函数依赖是多值函数依赖，所以如果主关系键只有一个属性，那么自动就满足了第二范式**
以刚才的例子来说：
现在有一个关系模式SCD(sno，cno，Score，sname)
          sno：学号 cno：课程号 Score：成绩 sname：姓名
在上面的部分函数依赖中已经分析得出，sname部分函数依赖于sno，所以这个关系模式没有达到第二范式，如何达到呢？
消除非主属性对主关系键的部分函数依赖。
拆分SCD
          S(sno,sname) SC(sno,cno,Score)

# 第三范式

第三范式（3NF）：每个非主属性都不传递函数依赖R的主关系键
**也就是说在第二范式的基础上，消除非主属性对主关系键的传递函数依赖，就可以成为第三范式。**
还是以刚才的例子来说：
现在有一个关系模式     R(sno,sname,dept,depter)
          sno:学号 sname:姓名 dept:院系 depter：院长
通过刚才的分析，非主属性depter传递函数依赖主关系键sno，所以不满足第三范式，这时就要消除depter对sno的传递函数依赖，拆分R
          S(sno,sname,dept)      D(dept,depter)

# BC范式

BC范式（BCNF）：消除主属性或非主属性对主关系键的部分函数依赖和传递函数依赖，就可以达到第三范式。
仔细分析这句话，可以排除很多无关因素，因为要达到BC范式，这时关系肯定已经达到了第三范式：已经消除了非主属性对主关系键的部分函数依赖和传递函数依赖。一般主要考虑的是主属性对主关系键的部分函数依赖。

举一个例子：
          关系模式SNO(sno,sid,cno,Score)
          sno:学号 sid：身份证号 cno：课程号 Score：成绩
分析该关系模式，很明显这是一个学生选课的关系，sno学号 和 sid身份证号都可以唯一的确定一个学生，但是确定不了选课关系，要想确定一个选课关系，还需要学号cno，也就是说这个关系有两个候选键(sno,cno)和(sid,cno)
          主属性：sno,sid,cno 非主属性：Score
分析发现已经满足第三范式，不存在非主属性的部分和传递函数依赖。

关系：
          sno<–>sid
          (sno,cno)–>Score,sid
          (sid,cno)–>Score,cid

这里面就存在了主属性对主关系键的部分函数依赖

sno->sid (sno,cno)->sid
所以sid部分函数依赖(sno,cno)
sid->sno (sid,cno)->sno
所以sno部分函数依赖(sid,cno)
要满足BC，可以拆分，消除这种关系
          A(sno,sn) B(sno,cno,Score)

# 总结

1. 第一个NF：唯一标识符，原子数据，无重复列。
2. 第二个NF：删除对复合主键的部分依赖。
3. 3rd NF：删除对非主键列的传递依赖。