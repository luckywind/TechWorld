# 消费者组

1. **队列模型**：早期消息处理引擎就是按照队列模型设计的，所谓队列模型，跟队列数据结构类似，生产者产生消息，就是入队，消费者接收消息就是出队，并删除队列中数据，消息只能被消费一次。**但这种模型有一个问题，那就是只能由一个消费者消费，无法直接让多个消费者消费数据。基于这个缺陷，后面又演化出发布-订阅模型**。

2. **发布-订阅模型**：发布订阅模型中，多了一个主题。消费者会预先订阅主题，生产者写入消息到主题中，只有订阅了该主题的消费者才能获取到消息。这样一来就可以让多个消费者消费数据。

<font color=red>以往的消息处理引擎大多只支持其中一种模型，但借助kafka的消费者组机制，可以同时实现这两种模型。同时还能够对消费组进行动态扩容，让消费变得易于伸缩。</font>

![img](https://piggo-picture.oss-cn-hangzhou.aliyuncs.com/1011838-20200130215849555-2146602672.png)

这张图应该很好的说明了消费者组，我们从上到下解释一下，kafka cluster中有两台broker服务器，每一台都有两个分区，这四个分区都是同一个topic下的。下左的消费者组A，组内有两个消费者，每个消费者负责两个分区的消费，而右边的消费者组B有四个消费者，每个负责消费一个分区。

消费者组内的所有成员一起订阅某个主题的所有分区，注意**一个消费者组中，每一个分区只能由组内的一个消费者订阅**。

所以：<font color=red>最好消费者组内消费者数量最好与分区数一致，或者成比例，这样不会导致消费者空闲</font>

## 重平衡

**重平衡**其实就是一个协议，它规定了如何让消费者组下的所有消费者来分配topic中的每一个分区。比如一个topic有100个分区，一个消费者组内有20个消费者，在协调者的控制下让组内每一个消费者分配到5个分区，这个分配的过程就是重平衡。

重平衡的触发条件主要有三个：

- 消费者组内成员发生变更，这个变更包括了增加和减少消费者。注意这里的减少有很大的可能是被动的，就是某个消费者崩溃退出了
- 主题的分区数发生变更，kafka目前只支持增加分区，当增加的时候就会触发重平衡
- 订阅的主题发生变化，当消费者组使用正则表达式订阅主题，而恰好又新建了对应的主题，就会触发重平衡

**三种重平衡策略**

kafka提供了三种重平衡分配策略，这里顺便介绍一下：

- Range

每个主题独立分配，会造成消费者最终消费的分区数不均衡

- RoundRobin

全部主题的分区平均分配，这种策略更加平衡，是默认的彭亨机制

- Sticky

又**称为粘性分配策略**，主要是为了让目前的分配尽可能保持不变，只挪动尽可能少的分区来实现重平衡。



**缺点**

在 Rebalance 过程中，所有 Consumer 实例都会停止消费，等待 Rebalance 完成。这是 Rebalance 为人诟病的一个方面。