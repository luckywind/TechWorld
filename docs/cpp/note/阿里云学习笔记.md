# 类型

创建枚举，需要使用关键字 **enum**。枚举类型的一般形式为：

```cpp
enum enum-name { list of names } var-list;
```

在这里，enum-name 是枚举类型的名称。名称列表 { list of names } 是用逗号分隔的。

例如，下面的代码定义了一个颜色枚举，变量 c 的类型为 color。最后，c 被赋值为 "blue"。

```cpp
enum color { red, green, blue } c;c = blue;
```

默认情况下，第一个名称的值为 0，第二个名称的值为 1，第三个名称的值为 2，以此类推。但是，您也可以给名称赋予一个特殊的值，只需要添加一个初始值即可。例如，在下面的枚举中，**green** 的值为 5。

```cpp
enum color { red, green=5, blue };
```

在这里，**blue** 的值为 6，因为默认情况下，每个名称都会比它前面一个名称大 1。

## 修饰符

C++ 允许在 **char、int 和 double** 数据类型前放置修饰符。修饰符用于改变基本类型的含义，所以它更能满足各种情境的需求。

下面列出了数据类型修饰符：

- signed
- unsigned
- long
- short

修饰符 **signed、unsigned、long 和 short** 可应用于整型，**signed** 和 **unsigned** 可应用于字符型，**long** 可应用于双精度型。

修饰符 **signed** 和 **unsigned** 也可以作为 **long** 或 **short** 修饰符的前缀。例如：**unsigned long int**。

C++ 允许使用速记符号来声明**无符号短整数**或**无符号长整数**。您可以不写 int，只写单词 **unsigned、short** 或 **unsigned、long**，int 是隐含的。例如，下面的两个语句都声明了无符号整型变量。

```cpp
unsigned x;
unsigned int y;
```



类限定符

类型限定符提供了变量的额外信息。

| 限定符   | 含义                                                         |
| :------- | :----------------------------------------------------------- |
| const    | **const** 类型的对象在程序执行期间不能被修改改变。           |
| volatile | 修饰符 **volatile** 告诉编译器，变量的值可能以程序未明确指定的方式被改变。 |
| restrict | 由 **restrict** 修饰的指针是唯一一种访问它所指向的对象的方式。只有 C99 增加了新的类型限定符 restrict。 |



# 变量

就是存储区域， 类型决定了它的大小和布局

除了常见的bool,char,int,float,double,void,wchar_t之外，C++ 也允许定义各种其他类型的变量，比如**枚举、指针、数组、引用、数据结构、类**等等。

变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序连接时编译器需要实际的变量声明。可以使用 **extern** 关键字在任何地方声明一个变量。

当局部变量被定义时，系统不会对其初始化，您必须自行对其初始化。定义全局变量时，系统会自动初始化为下列值：

| 数据类型 | 初始化默认值 |
| :------- | :----------- |
| int      | 0            |
| char     | '\0'         |
| float    | 0            |
| double   | 0            |
| pointer  | NULL         |

正确地初始化变量是一个良好的编程习惯，否则有时候程序可能会产生意想不到的结果。

# 常量

定义常量

在 C++ 中，有两种简单的定义常量的方式：

- 使用 **#define** 预处理器。
- 使用 **const** 关键字。



# 存储类

存储类定义 C++ 程序中变量/函数的范围（可见性）和生命周期。这些说明符放置在它们所修饰的类型之前。下面列出 C++ 程序中可用的存储类：

- auto

- register:  **register** 存储类用于定义存储在寄存器中而不是 RAM 中的局部变量。

- static: **static** 存储类指示编译器在程序的生命周期内保持局部变量的存在，而不需要在每次它进入和离开作用域时进行创建和销毁。因此，使用 static 修饰局部变量可以在函数调用之间保持局部变量的值。

- extern:**extern** 存储类用于提供一个全局变量的引用，全局变量对所有的程序文件都是可见的。是用来在另一个文件中声明一个全局变量或函数。

- mutable

- thread_local (C++11)

- 使用 thread_local 说明符声明的变量仅可在它在其上创建的线程上访问。 变量在创建线程时创建，并在销毁线程时销毁。 每个线程都有其自己的变量副本。

  thread_local 说明符可以与 static 或 extern 合并。

从 C++ 11 开始，auto 关键字不再是 C++ 存储类说明符，且 register 关键字被弃用。

# 数组

所有的数组都是由连续的内存位置组成。最低的地址对应第一个元素，最高的地址对应最后一个元素。

| 概念           | 描述                                                         |
| :------------- | :----------------------------------------------------------- |
| 多维数组       | C++ 支持多维数组。多维数组最简单的形式是二维数组。           |
| 指向数组的指针 | 您可以通过指定不带索引的数组名称来生成一个指向数组中第一个元素的指针。 |
| 传递数组给函数 | 您可以通过指定不带索引的数组名称来给函数传递一个指向数组的指针。 |
| 从函数返回数组 | C++ 允许从函数返回数组。                                     |

# 字符串

- C风格字符串： C 风格的字符串起源于 C 语言，并在 C++ 中继续得到支持。字符串实际上是使用 **null** 字符 '\0' 终止的一维字符数组。
- C++中的String类：另外还增加了其他更多的功能

| 序号 | 函数 & 目的                                                  |
| :--- | :----------------------------------------------------------- |
| 1    | **strcpy(s1, s2);** 复制字符串 s2 到字符串 s1。              |
| 2    | **strcat(s1, s2);** 连接字符串 s2 到字符串 s1 的末尾。       |
| 3    | **strlen(s1);** 返回字符串 s1 的长度。                       |
| 4    | **strcmp(s1, s2);** 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |
| 5    | **strchr(s1, ch);** 返回一个指针，指向字符串 s1 中字符 ch 的第一次出现的位置。 |
| 6    | **strstr(s1, s2);** 返回一个指针，指向字符串 s1 中字符串 s2 的第一次出现的位置。 |

# 指针

**指针**是一个变量，其值为另一个变量的地址，即，内存位置的直接地址

形式： type *var-name;

所有指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数。不同数据类型的指针之间唯一的不同是，指针所指向的变量或常量的数据类型不同。

| 概念               | 描述                                                         |
| :----------------- | :----------------------------------------------------------- |
| C++ Null 指针      | C++ 支持空指针。NULL 指针是一个定义在标准库中的值为零的常量。 |
| C++ 指针的算术运算 | 可以对指针进行四种算术运算：++、--、+、-                     |
| C++ 指针 vs 数组   | 指针和数组之间有着密切的关系。                               |
| C++ 指针数组       | 可以定义用来存储指针的数组。                                 |
| C++ 指向指针的指针 | C++ 允许指向指针的指针。                                     |
| C++ 传递指针给函数 | 通过引用或地址传递参数，使传递的参数在调用函数中被改变。     |
| C++ 从函数返回指针 | C++ 允许函数返回指针到局部变量、静态变量和动态内存分配。     |

[详解指针](https://blog.csdn.net/xierhacker/article/details/52516742)



## 指针常量vs常量指针

- 指针常量：<font color=red>指针不能再指向其他地址了,   const 修饰的是int*</font>

  ```c
  int x[] = { 1, 2, 3, 4 };
  int* const p = x;
  ```

  

- 常量指针：是指向常量数据的指针，它指向的数据当作常量处理。const修饰的是int类型，而非指针

```c
    int x =1, y=2;
    int const *p =&x; //const只是说:我们把x当作常量处理！
    p=&y;  //p并非常量哦，它可以指向其他地址的！
    printf("%d\n", *p);
//    *p=100;  //错误！，p声明时已经指定它的对象是常量了哦
```

## 指针的指针

```c
int x = 10;
int* p = &x;
int** p2 = &p;

printf("p = %p, *p = %d\n", p, *p);
printf("p2 = %p, *p2 = %x\n", p2, *p2);
printf("x = %d, %d\n",*p, **p2);
p = 0xbfba3e5c, *p = 10
p2 = 0xbfba3e58, *p2 = bfba3e5c
x = 10, 10
```

## 数组指针

数组名为指向该数组第一个元素的指针常量。

```c
int x[] = {1,2,3,4,5,6};

int *p1 = x;  // 指向整数的指针
int (*p2)[] = &x;  // 指向数组的指针, p2的类型是数组类型，因此p2的目标是数组，而不是数组的一个元素，所以指针指向是是什么是有指针的类型决定的
```

p1 的类型是 int，也就是说它指向一个整数类型。数组名默认指向数组中的第一个元素，因此 x 默认也是 int 类型。
p2 的含义是指向一个 "数组类型" 的指针，注意是 "数组类型" 而不是 "数组元素类型"，这有本质上的区别。
数组指针把数组当做一个整体，因为从类型角度来说，数组类型和数组元素类型是两个概念。&x 取的是数组指针，而不是"第一个元素指针的指针



## 指针数组

元素类型为指针的数组称之为指针数组。

```c
int x[] = { 1, 2, 3, 4 };
int* ps[] = { x, x + 1, x + 2, x + 3 };

for(int i = 0; i < 4; i++)
{
    printf("%d\n", *(ps[i]));
}
```



## 函数指针

函数名就是指向该函数的指针常量

```c
void inc(int* x)
{
    *x += 1;
}

int main(void)
{
    void (*f)(int*) = inc;

    int i = 100;
    f(&i);
    printf("%d\n", i);

    return 0;
}
```

> 可以使用typedef定义一个类型` typedef void (*inc_t)(int*);`

## 



# [引用](https://developer.aliyun.com/article/1423812?spm=a2c6h.13262185.profile.15.79007f764GXeoX)

引用变量是一个别名，也就是说，它是某个已存在变量的另一个名字。一旦把引用初始化为某个变量，就可以使用该引用名称或变量名称来指向变量。

引用必须在创建时被初始化，不存在空引用，必须连接到一块合法的内存。

1. 引用在定义时必须初始化

2. 一个变量可以有多个引用

3. 引用一旦引用一个实体，再不能引用其他实体
4. 传递函数参数:通过引用传递函数参数，可以在函数内部修改原始变量的值，而无需进行拷贝。

形式： int&    r = i;

## 引用和指针的不同点

> **🔴引用概念上定义一个变量的别名，指针存储一个变量地址。
> 🔴引用在定义时必须初始化，指针没有要求
> 🔴引用在初始化时引用一个实体后，就不能再引用其他实体，而指针可以在任何时候指向任何一个同类型实体
> 🔴没有NULL引用，但有NULL指针
> 🔴在sizeof中含义不同：引用结果为引用类型的大小，但指针始终是地址空间所占字节个数(32位平台下占4个字节)
> 🔴引用自加即引用的实体增加1，指针自加即指针向后偏移一个类型的大小**
>
> **🔴有多级指针，但是没有多级引用**
>
> **🔴访问实体方式不同，指针需要显式解引用，引用编译器自己处理
> 🔴引用比指针使用起来相对更安全**



# 数据结构

C/C++ 数组允许定义可存储相同类型数据项的变量，但是**结构**是 C++ 中另一种用户自定义的可用的数据类型，它允许您存储不同类型的数据项。

为了定义结构，您必须使用 **struct** 语句。struct 语句定义了一个包含多个成员的新的数据类型，struct 语句的格式如下：

```cpp
struct type_name {member_type1 member_name1;member_type2 member_name2;member_type3 member_name3;

} 
object_names;
```

例如：

```cpp
struct Books{
   char  title[50];   char  author[50];   char  subject[100];   
   int   book_id;} 
book;
```

可以定义指向结构的指针，方式与定义指向其他类型变量的指针相似，如下所示：

```cpp
struct Books *struct_pointer; //注意前面需要加上struct
struct_pointer = &Book1;  //初始化指针
struct_pointer->title;  //访问结构的成员
```

typedef关键字：下面是一种更简单的定义结构的方式，您可以为创建的类型取一个"别名"。例如：

```cpp
typedef struct{
   char  title[50];
   char  author[50];
   char  subject[100];
   int   book_id;}Books;
```

现在，您可以直接使用 *Books* 来定义 *Books* 类型的变量，而不需要使用 struct 关键字。下面是实例：

```cpp
Books Book1, Book2; //不再需要struct修饰
```

您可以使用 **typedef** 关键字来定义非结构类型，如下所示：

```cpp
typedef long int *pint32;
 pint32 x, y, z;
```

x, y 和 z 都是指向长整型 long int 的指针。

# 类/对象

| 概念                                                         | 描述                                                         |
| :----------------------------------------------------------- | :----------------------------------------------------------- |
| [类成员函数](https://edu.aliyun.com/cplusplus/cpp-class-member-functions.html) | 类的成员函数是指那些把定义和原型写在类定义内部的函数，就像类定义中的其他变量一样。 |
| [类访问修饰符](https://edu.aliyun.com/cplusplus/cpp-class-access-modifiers.html) | 类成员可以被定义为 public、private 或 protected。默认情况下是定义为 private。 |
| [构造函数 & 析构函数](https://edu.aliyun.com/cplusplus/cpp-constructor-destructor.html) | 类的构造函数是一种特殊的函数，在创建一个新的对象时调用。类的析构函数也是一种特殊的函数，在删除所创建的对象时调用。 |
| [C++ 拷贝构造函数](https://edu.aliyun.com/cplusplus/cpp-copy-constructor.html) | 拷贝构造函数，是一种特殊的构造函数，它在创建对象时，是使用同一类中之前创建的对象来初始化新创建的对象。 |
| [C++ 友元函数](https://edu.aliyun.com/cplusplus/cpp-friend-functions.html) | **友元函数**可以访问类的 private 和 protected 成员。         |
| [C++ 内联函数](https://edu.aliyun.com/cplusplus/cpp-inline-functions.html) | 通过内联函数，编译器试图在调用函数的地方扩展函数体中的代码。 |
| [C++ 中的 this 指针](https://edu.aliyun.com/cplusplus/cpp-this-pointer.html) | 每个对象都有一个特殊的指针 **this**，它指向对象本身。        |
| [C++ 中指向类的指针](https://edu.aliyun.com/cplusplus/cpp-pointer-to-class.html) | 指向类的指针方式如同指向结构的指针。实际上，**类可以看成是一个带有函数的结构**。 |
| [C++ 类的静态成员](https://edu.aliyun.com/cplusplus/cpp-static-members.html) | 类的数据成员和函数成员都可以被声明为静态的。                 |

## [类和对象](https://developer.aliyun.com/article/1423854?spm=a2c6h.13262185.profile.14.79007f764GXeoX)

## [类和对象（构造函数、析构函数）](https://developer.aliyun.com/article/1424132?spm=a2c6h.13262185.profile.13.79007f764GXeoX)

#  继承

继承类型

当一个类派生自基类，该基类可以被继承为 **public、protected** 或 **private** 几种类型。继承类型是通过上面讲解的访问修饰符 access-specifier 来指定的。

我们几乎不使用 **protected** 或 **private** 继承，通常使用 **public** 继承。当使用不同类型的继承时，遵循以下几个规则：

- **公有继承（public）：**当一个类派生自**公有**基类时，基类的**公有**成员也是派生类的**公有**成员，基类的**保护**成员也是派生类的**保护**成员，基类的**私有**成员不能直接被派生类访问，但是可以通过调用基类的**公有**和**保护**成员来访问。
- **保护继承（protected）：** 当一个类派生自**保护**基类时，基类的**公有**和**保护**成员将成为派生类的**保护**成员。
- **私有继承（private）：**当一个类派生自**私有**基类时，基类的**公有**和**保护**成员将成为派生类的**私有**成员。

```cpp
class Rectangle : public Shape {
public:
    int getArea() {
        return (width * height);
    }
};
```

## 多继承

语法：`class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,…{<派生类类体>};`

```cpp
class Rectangle : public Shape, public PaintCost {
public:
    int getArea() {
        return (width * height);
    }
};
```

# 多态

C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

-  **虚函数：** 是在基类中使用关键字 **virtual** 声明的函数。在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。我们想要的是在程序中任意点可以根据所调用的对象类型来选择调用的函数，这种操作被称为**动态链接**，或**后期绑定**。

  ```c++
  virtual int area()
        {
           cout << "Parent class area :" <<endl;
           return 0;
        }
  ```

  

- **纯虚函数**：您可能想要在基类中定义虚函数，以便在派生类中重新定义该函数更好地适用于对象，但是您在基类中又不能对虚函数给出有意义的实现，这个时候就会用到纯虚函数。

  ```cpp
  virtual int area() = 0;    //= 0 告诉编译器，函数没有主体，上面的虚函数是纯虚函数。
  ```

  

# c++数据抽象

数据抽象是指，只向外界提供关键信息，并隐藏其后台的实现细节，即只表现必要的信息而不呈现细节。

# [命名空间](https://developer.aliyun.com/article/1423701?spm=a2c6h.13262185.profile.18.79007f76PFB91o)

命名空间可以定义在几个不同的部分中，因此命名空间是由几个单独定义的部分组成的。一个命名空间的各个组成部分可以分散在多个文件中。

1. 可以嵌套定义、可以重名(重名会合并)
2. 不可以局部定义，即在函数内部定义
3. 命名空间中的函数，可以通过作用域在外面定义
4. 匿名命名空间，只能在本文件内访问

## 使用

1. using引入指定变量
2. using namespace xxx 引入命名空间中所有变量

# [内存管理](https://developer.aliyun.com/article/1425503?spm=a2c6h.13262185.profile.12.52b37f76es6uQi)

1. malloc函数

   **malloc** 函数用于动态地分配指定大小的内存空间。

   **它接受一个参数，即需要分配的内存大小（以字节为单位），并返回所分配内存的起始地址。**

   **malloc** 函数在堆上找到足够大的连续内存空间进行分配，如果找不到足够大的连续空间，则返回 **NULL**

   分配的内存是未初始化的，即其中的数据是不确定的，需要手动初始化。

2. calloc函数

   **calloc** 函数用于动态地分配指定数量和大小的内存空间，并将其初始化为**0**。

   **它接受两个参数，第一个是需要分配的元素数量，第二个是每个元素的大小（以字节为单位）。**	

   **calloc** 函数在堆上找到足够大的内存空间进行分配，并将所有字节初始化为**0**。
   分配的内存是初始化过的，不需要手动初始化。

3. realloc函数
   重新调整之前分配的内存空间的大小,若新大小大于原始大小，则新增的字节未初始化；若新大小小于原始大小，则超出新大小的部分将被丢弃。







